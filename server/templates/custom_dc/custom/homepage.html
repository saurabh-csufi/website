{#
 Copyright 2023 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
#}

{%- extends BASE_HTML -%}

{% set main_id = 'homepage' %}
{% set page_id = 'page-homepage' %}

{% block head %}
  {{ super() }}
  <style>
    /* Chat Interface Styles */
    .gemini-chat-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      height: calc(100vh - 200px);
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      text-align: center;
      margin-bottom: 20px;
    }

    .chat-header h1 {
      font-size: 1.75rem;
      color: #1a1a2e;
      margin-bottom: 8px;
    }

    .chat-header p {
      color: #666;
      font-size: 0.95rem;
    }

    .config-section {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .config-section.hidden {
      display: none;
    }

    .config-row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .config-row:last-child {
      margin-bottom: 0;
    }

    .config-section label {
      font-weight: 500;
      color: #856404;
      white-space: nowrap;
      min-width: 120px;
    }

    .config-section input[type="password"],
    .config-section input[type="text"] {
      flex: 1;
      min-width: 200px;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }

    .config-section button {
      background: #ffc107;
      color: #856404;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
    }

    .config-section button:hover {
      background: #e0a800;
    }

    .config-status {
      width: 100%;
      font-size: 0.85rem;
      color: #856404;
      margin-top: 8px;
    }

    .config-status.success {
      color: #155724;
    }

    .config-status.error {
      color: #721c24;
    }

    .mcp-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mcp-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .mcp-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .mcp-status.connected {
      background: #d4edda;
      color: #155724;
    }

    .mcp-status.disconnected {
      background: #f8d7da;
      color: #721c24;
    }

    .mcp-status.checking {
      background: #fff3cd;
      color: #856404;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      margin-bottom: 16px;
      min-height: 300px;
    }

    .message {
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: #4285f4;
      color: white;
    }

    .message.assistant .message-avatar {
      background: #34a853;
      color: white;
    }

    .message-content {
      max-width: 75%;
      padding: 12px 16px;
      border-radius: 12px;
      line-height: 1.5;
    }

    .message.user .message-content {
      background: #4285f4;
      color: white;
      border-bottom-right-radius: 4px;
    }

    .message.assistant .message-content {
      background: white;
      color: #1a1a2e;
      border-bottom-left-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .message-content p {
      margin: 0 0 8px 0;
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content pre {
      background: #f1f3f4;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 8px 0;
    }

    .message-content code {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.9em;
    }

    .tool-call-indicator {
      background: #e8f0fe;
      border: 1px solid #4285f4;
      border-radius: 8px;
      padding: 10px 14px;
      margin: 8px 0;
      font-size: 0.85rem;
      color: #1a73e8;
    }

    .tool-call-indicator.loading {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .tool-call-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .tool-call-args {
      color: #5f6368;
      font-family: monospace;
      font-size: 0.8rem;
      background: rgba(255,255,255,0.5);
      padding: 6px 10px;
      border-radius: 4px;
      word-break: break-all;
    }

    .tool-call-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(66, 133, 244, 0.3);
      color: #1e8e3e;
      font-size: 0.8rem;
    }

    .tool-call-result.error {
      color: #d93025;
    }

    .chat-input-area {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 16px;
    }

    .file-upload-area {
      margin-bottom: 12px;
    }

    .file-drop-zone {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .file-drop-zone:hover,
    .file-drop-zone.drag-over {
      border-color: #4285f4;
      background: #f0f7ff;
    }

    .file-drop-zone input[type="file"] {
      display: none;
    }

    .file-drop-zone .drop-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    .file-drop-zone .drop-text {
      color: #666;
      font-size: 0.9rem;
    }

    .file-drop-zone .drop-text span {
      color: #4285f4;
      font-weight: 500;
    }

    .uploaded-files {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .uploaded-file {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #e8f0fe;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
    }

    .uploaded-file .file-icon {
      color: #4285f4;
    }

    .uploaded-file .remove-file {
      cursor: pointer;
      color: #666;
      font-size: 16px;
    }

    .uploaded-file .remove-file:hover {
      color: #d93025;
    }

    .chat-input-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .chat-input-wrapper {
      flex: 1;
    }

    #chat-input {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 24px;
      padding: 12px 20px;
      font-size: 1rem;
      resize: none;
      min-height: 48px;
      max-height: 150px;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s;
    }

    #chat-input:focus {
      border-color: #4285f4;
    }

    #chat-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    #send-btn {
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    #send-btn:hover:not(:disabled) {
      background: #3367d6;
    }

    #send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    #send-btn svg {
      width: 20px;
      height: 20px;
    }

    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 12px 16px;
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: #666;
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-8px); }
    }

    .welcome-message {
      text-align: center;
      padding: 40px 20px;
      color: #666;
    }

    .welcome-message h2 {
      color: #1a1a2e;
      margin-bottom: 12px;
    }

    .welcome-message .suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 20px;
    }

    .welcome-message .suggestion {
      background: white;
      border: 1px solid #ddd;
      border-radius: 20px;
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .welcome-message .suggestion:hover:not(:disabled) {
      border-color: #4285f4;
      background: #f0f7ff;
    }

    .welcome-message .suggestion:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .error-message {
      background: #fce8e6;
      color: #d93025;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .gemini-chat-container {
        padding: 10px;
        height: calc(100vh - 150px);
      }

      .message-content {
        max-width: 85%;
      }

      .chat-header h1 {
        font-size: 1.5rem;
      }

      .config-row {
        flex-direction: column;
        align-items: stretch;
      }

      .config-section input {
        width: 100%;
      }

      .config-section label {
        min-width: auto;
      }
    }
  </style>
{% endblock %}

{% block content %}
  <div class="gemini-chat-container">
    <div class="chat-header">
      <h1>Data Commons AI Assistant</h1>
      <p>Ask questions about statistics, upload PDFs, and explore data powered by Gemini AI + Data Commons MCP</p>
    </div>

    <div class="config-section" id="config-section">
      <div class="config-row">
        <label for="api-key-input">Gemini API Key:</label>
        <input type="password" id="api-key-input" placeholder="Enter your Gemini API key">
      </div>

      <div class="config-row">
        <label for="mcp-url-input">MCP Proxy URL:</label>
        <input type="text" id="mcp-url-input" placeholder="http://localhost:5001" value="http://localhost:5001">
        <div class="mcp-toggle">
          <input type="checkbox" id="mcp-enabled" checked>
          <label for="mcp-enabled">Use MCP Tools</label>
        </div>
        <span class="mcp-status disconnected" id="mcp-status">Disconnected</span>
      </div>

      <div class="config-row">
        <button id="save-config">Save & Connect</button>
      </div>

      <div class="config-status" id="config-status">
        Get Gemini key from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>.
        Run MCP proxy: <code>python additional_features/mcp_proxy_server.py</code>
      </div>
    </div>

    <div class="chat-messages" id="chat-messages">
      <div class="welcome-message" id="welcome-message">
        <h2>How can I help you today?</h2>
        <p>Configure your settings above, then ask questions about data or upload documents</p>
        <div class="suggestions">
          <button class="suggestion" data-text="What is the population of California?" disabled>Population of California</button>
          <button class="suggestion" data-text="What is the GDP of Germany?" disabled>GDP of Germany</button>
          <button class="suggestion" data-text="What is the life expectancy in Japan?" disabled>Life expectancy in Japan</button>
        </div>
      </div>
    </div>

    <div class="chat-input-area">
      <div class="file-upload-area">
        <div class="file-drop-zone" id="file-drop-zone">
          <div class="drop-icon">ðŸ“„</div>
          <div class="drop-text">
            Drag & drop PDF files here or <span>browse</span>
          </div>
          <input type="file" id="file-input" accept=".pdf" multiple>
        </div>
        <div class="uploaded-files" id="uploaded-files"></div>
      </div>

      <div class="chat-input-row">
        <div class="chat-input-wrapper">
          <textarea
            id="chat-input"
            placeholder="Configure settings first..."
            rows="1"
            disabled
          ></textarea>
        </div>
        <button id="send-btn" title="Send message" disabled>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      // Configuration
      const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta/models';
      const GEMINI_MODEL = 'gemini-2.0-flash';

      // State
      let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
      let mcpProxyUrl = localStorage.getItem('mcp_proxy_url') || 'http://localhost:5001';
      let mcpEnabled = localStorage.getItem('mcp_enabled') !== 'false';
      let mcpTools = [];
      let mcpConnected = false;
      let uploadedFiles = [];
      let conversationHistory = [];
      let isProcessing = false;

      // DOM Elements
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const fileInput = document.getElementById('file-input');
      const fileDropZone = document.getElementById('file-drop-zone');
      const uploadedFilesContainer = document.getElementById('uploaded-files');
      const welcomeMessage = document.getElementById('welcome-message');
      const configSection = document.getElementById('config-section');
      const apiKeyInput = document.getElementById('api-key-input');
      const mcpUrlInput = document.getElementById('mcp-url-input');
      const mcpEnabledCheckbox = document.getElementById('mcp-enabled');
      const mcpStatusEl = document.getElementById('mcp-status');
      const saveConfigBtn = document.getElementById('save-config');
      const configStatus = document.getElementById('config-status');

      // System instruction
      const systemInstruction = `You are a Data Commons AI assistant with access to real-time statistical data tools.

CRITICAL: When users ask about ANY statistics, data, numbers, demographics, economics, health, environment, population, GDP, unemployment, or similar quantitative information:
1. You MUST use the available tools to fetch real data - NEVER make up numbers or provide code examples
2. First call search_indicators to find the right variable DCID for the query
3. Then call get_observations with the variable and place DCIDs to get actual data
4. Present the data clearly with the actual numbers and dates from the tool response

Tool workflow for data queries:
- Step 1: search_indicators(query="population", places=["California, USA"]) -> get variable DCID
- Step 2: get_observations(variable_dcid="...", place_dcid="...") -> get actual data
- Step 3: Present the numbers from the response

DO NOT generate Python code or tell users how to query - use the tools yourself and return the actual data.

You can also analyze PDF documents that users upload.
Be concise but comprehensive. Cite "Data Commons" as the source when presenting data.`;

      // Initialize
      function init() {
        // Load saved config
        if (geminiApiKey) apiKeyInput.value = geminiApiKey;
        if (mcpProxyUrl) mcpUrlInput.value = mcpProxyUrl;
        mcpEnabledCheckbox.checked = mcpEnabled;

        // Event listeners
        saveConfigBtn.addEventListener('click', saveConfig);
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', handleKeyDown);
        chatInput.addEventListener('input', autoResize);
        fileInput.addEventListener('change', handleFileSelect);
        fileDropZone.addEventListener('click', () => fileInput.click());
        fileDropZone.addEventListener('dragover', handleDragOver);
        fileDropZone.addEventListener('dragleave', handleDragLeave);
        fileDropZone.addEventListener('drop', handleDrop);

        // Suggestion buttons
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.addEventListener('click', () => {
            if (!btn.disabled) {
              chatInput.value = btn.dataset.text;
              sendMessage();
            }
          });
        });

        // Auto-connect if config exists
        if (geminiApiKey) {
          saveConfig();
        }
      }

      // Save configuration and connect
      async function saveConfig() {
        const key = apiKeyInput.value.trim();
        const url = mcpUrlInput.value.trim();
        const enabled = mcpEnabledCheckbox.checked;

        if (!key) {
          configStatus.textContent = 'Please enter a Gemini API key';
          configStatus.className = 'config-status error';
          return;
        }

        geminiApiKey = key;
        mcpProxyUrl = url;
        mcpEnabled = enabled;

        localStorage.setItem('gemini_api_key', key);
        localStorage.setItem('mcp_proxy_url', url);
        localStorage.setItem('mcp_enabled', enabled.toString());

        configStatus.textContent = 'Connecting...';
        configStatus.className = 'config-status';

        // Check MCP connection if enabled
        if (mcpEnabled && url) {
          mcpStatusEl.textContent = 'Checking...';
          mcpStatusEl.className = 'mcp-status checking';

          const connected = await checkMcpConnection();
          if (connected) {
            mcpConnected = true;
            mcpStatusEl.textContent = `Connected (${mcpTools.length} tools)`;
            mcpStatusEl.className = 'mcp-status connected';
          } else {
            mcpConnected = false;
            mcpStatusEl.textContent = 'Disconnected';
            mcpStatusEl.className = 'mcp-status disconnected';
          }
        } else {
          mcpConnected = false;
          mcpStatusEl.textContent = 'Disabled';
          mcpStatusEl.className = 'mcp-status disconnected';
        }

        enableChat();
        configStatus.textContent = 'Configuration saved! You can now start chatting.';
        configStatus.className = 'config-status success';

        setTimeout(() => {
          configSection.classList.add('hidden');
        }, 2000);
      }

      // Check MCP proxy connection and fetch tools
      async function checkMcpConnection() {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/tools`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });

          if (!response.ok) return false;

          const data = await response.json();
          if (data.success && data.tools) {
            mcpTools = data.tools;
            console.log('MCP Tools loaded:', mcpTools.map(t => t.name));
            return true;
          }
          return false;
        } catch (err) {
          console.error('MCP connection error:', err);
          return false;
        }
      }

      // Execute MCP tool call
      async function executeMcpToolCall(name, args) {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/call`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, arguments: args })
          });

          const data = await response.json();

          if (data.success && data.result) {
            // Extract text content from MCP result
            const content = data.result.content;
            if (Array.isArray(content)) {
              return content.map(c => c.text || JSON.stringify(c)).join('\n');
            }
            return JSON.stringify(data.result);
          }

          return JSON.stringify({ error: data.error || 'Unknown error' });
        } catch (err) {
          console.error('MCP tool call error:', err);
          return JSON.stringify({ error: err.message });
        }
      }

      function enableChat() {
        chatInput.disabled = false;
        chatInput.placeholder = mcpConnected
          ? 'Ask about data, statistics, or upload documents...'
          : 'Ask questions or upload documents...';
        sendBtn.disabled = false;
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.disabled = false;
        });
      }

      // Auto-resize textarea
      function autoResize() {
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';
      }

      function handleKeyDown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      }

      // File handling
      function handleDragOver(e) {
        e.preventDefault();
        fileDropZone.classList.add('drag-over');
      }

      function handleDragLeave(e) {
        e.preventDefault();
        fileDropZone.classList.remove('drag-over');
      }

      function handleDrop(e) {
        e.preventDefault();
        fileDropZone.classList.remove('drag-over');
        const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
        processFiles(files);
      }

      function handleFileSelect(e) {
        const files = Array.from(e.target.files);
        processFiles(files);
        e.target.value = '';
      }

      async function processFiles(files) {
        for (const file of files) {
          if (file.size > 20 * 1024 * 1024) {
            showError(`File "${file.name}" is too large. Maximum size is 20MB.`);
            continue;
          }

          try {
            const base64 = await fileToBase64(file);
            uploadedFiles.push({
              name: file.name,
              data: base64,
              mimeType: 'application/pdf'
            });
            renderUploadedFiles();
          } catch (err) {
            showError(`Failed to process "${file.name}"`);
          }
        }
      }

      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      function renderUploadedFiles() {
        uploadedFilesContainer.innerHTML = uploadedFiles.map((file, index) => `
          <div class="uploaded-file">
            <span class="file-icon">ðŸ“„</span>
            <span class="file-name">${escapeHtml(file.name)}</span>
            <span class="remove-file" data-index="${index}">&times;</span>
          </div>
        `).join('');

        document.querySelectorAll('.remove-file').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index);
            uploadedFiles.splice(index, 1);
            renderUploadedFiles();
          });
        });
      }

      // Show tool call in UI
      function showToolCall(name, args) {
        const toolEl = document.createElement('div');
        toolEl.className = 'tool-call-indicator loading';
        toolEl.innerHTML = `
          <div class="tool-call-header">
            <span>ðŸ”§</span>
            <span>${escapeHtml(name)}</span>
          </div>
          <div class="tool-call-args">${escapeHtml(JSON.stringify(args, null, 2))}</div>
          <div class="tool-call-result"></div>
        `;
        chatMessages.appendChild(toolEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return toolEl;
      }

      function updateToolCallResult(toolEl, result, isError = false) {
        toolEl.classList.remove('loading');
        const resultEl = toolEl.querySelector('.tool-call-result');
        resultEl.className = `tool-call-result${isError ? ' error' : ''}`;

        // Truncate long results
        let displayResult = result;
        if (result.length > 500) {
          displayResult = result.substring(0, 500) + '... (truncated)';
        }
        resultEl.textContent = displayResult;
      }

      // Send message with function calling
      async function sendMessage() {
        const message = chatInput.value.trim();
        if ((!message && uploadedFiles.length === 0) || isProcessing || !geminiApiKey) return;

        // Hide welcome message
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }

        // Show user message
        let displayMessage = message;
        if (uploadedFiles.length > 0) {
          const fileNames = uploadedFiles.map(f => f.name).join(', ');
          displayMessage = message ? `ðŸ“„ ${fileNames}\n\n${message}` : `ðŸ“„ Uploaded: ${fileNames}`;
        }
        addMessage('user', displayMessage);

        // Clear input
        chatInput.value = '';
        autoResize();

        // Start processing
        isProcessing = true;
        sendBtn.disabled = true;
        chatInput.disabled = true;
        let typingEl = showTypingIndicator();

        try {
          // Build contents
          const contents = [...conversationHistory];

          const currentParts = [];
          if (uploadedFiles.length > 0) {
            currentParts.push({
              inline_data: {
                mime_type: uploadedFiles[0].mimeType,
                data: uploadedFiles[0].data
              }
            });
          }

          const userMessage = message || 'Please analyze this document and provide a summary.';
          currentParts.push({ text: userMessage });
          contents.push({ role: 'user', parts: currentParts });

          // Function calling loop
          let maxIterations = 5;
          let iteration = 0;
          let finalResponse = null;

          while (iteration < maxIterations) {
            iteration++;

            // Build payload
            const payload = {
              contents: contents,
              systemInstruction: { parts: [{ text: systemInstruction }] },
              generationConfig: {
                temperature: 0.7,
                topP: 0.95,
                topK: 40
              }
            };

            // Add tools if MCP is connected
            if (mcpConnected && mcpTools.length > 0) {
              // Check if query looks like a data request
              const dataKeywords = /population|gdp|unemployment|rate|statistics|data|how many|what is the|number of|percent|average|median|income|health|economy|demographics|emissions|climate|crime|education/i;
              const isDataQuery = dataKeywords.test(userMessage);

              // Iteration 1: Force tool call for data queries (ANY mode)
              // Iteration 2: Allow tool OR text (AUTO mode)
              // Iteration 3+: Force text response - don't include tools
              if (iteration >= 3) {
                // Don't include tools - force pure text response
                console.log(`Iteration ${iteration}: Forcing text response (no tools)`);
              } else {
                // Simplify tool descriptions for Gemini (truncate long ones)
                const simplifiedTools = mcpTools.map(t => ({
                  name: t.name,
                  description: t.description.length > 500
                    ? t.description.substring(0, 500) + '...'
                    : t.description,
                  parameters: t.parameters
                }));
                payload.tools = [{ functionDeclarations: simplifiedTools }];

                const mode = (iteration === 1 && isDataQuery) ? 'ANY' : 'AUTO';
                console.log(`Iteration ${iteration}: Using mode ${mode}`);
                payload.toolConfig = {
                  functionCallingConfig: { mode: mode }
                };
              }
            }

            // Call Gemini
            const response = await fetch(
              `${GEMINI_API_BASE}/${GEMINI_MODEL}:generateContent?key=${geminiApiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              }
            );

            const data = await response.json();

            if (data.error) {
              throw new Error(data.error.message || 'API request failed');
            }

            const candidates = data.candidates || [];
            if (candidates.length === 0) {
              throw new Error('No response from AI');
            }

            const responseParts = candidates[0].content?.parts || [];
            const functionCalls = responseParts.filter(p => p.functionCall);

            if (functionCalls.length > 0 && mcpConnected) {
              // Remove typing indicator
              typingEl.remove();

              // Add model response to conversation
              contents.push({ role: 'model', parts: responseParts });

              // Execute tool calls
              const functionResponses = [];
              for (const part of functionCalls) {
                const fc = part.functionCall;
                const toolEl = showToolCall(fc.name, fc.args);

                try {
                  const result = await executeMcpToolCall(fc.name, fc.args);
                  updateToolCallResult(toolEl, result, false);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { result: result }
                    }
                  });
                } catch (err) {
                  updateToolCallResult(toolEl, err.message, true);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { error: err.message }
                    }
                  });
                }
              }

              // Add function responses
              contents.push({ role: 'user', parts: functionResponses });

              // Show typing indicator again
              typingEl = showTypingIndicator();

            } else {
              // Final response (no function calls)
              const textParts = responseParts.filter(p => p.text);
              if (textParts.length > 0) {
                finalResponse = textParts.map(p => p.text).join('\n');
              }
              break;
            }
          }

          // Remove typing indicator
          typingEl.remove();

          if (finalResponse) {
            addMessage('assistant', finalResponse);

            // Update conversation history
            conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
            conversationHistory.push({ role: 'model', parts: [{ text: finalResponse }] });

            // Clear files
            uploadedFiles = [];
            renderUploadedFiles();
          } else {
            showError('No response from AI');
          }

        } catch (err) {
          if (typingEl && typingEl.parentNode) typingEl.remove();
          console.error('Chat error:', err);

          if (err.message.includes('API key')) {
            showError('Invalid API key. Please check your Gemini API key.');
            configSection.classList.remove('hidden');
          } else {
            showError(`Error: ${err.message}`);
          }
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          chatInput.disabled = false;
          chatInput.focus();
        }
      }

      // UI helpers
      function addMessage(role, content) {
        const messageEl = document.createElement('div');
        messageEl.className = `message ${role}`;

        const avatar = role === 'user' ? 'U' : 'AI';
        const formattedContent = formatMessage(content);

        messageEl.innerHTML = `
          <div class="message-avatar">${avatar}</div>
          <div class="message-content">${formattedContent}</div>
        `;

        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function formatMessage(content) {
        let formatted = escapeHtml(content);
        formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
        formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        formatted = formatted.replace(/\n/g, '<br>');
        return formatted;
      }

      function showTypingIndicator() {
        const typingEl = document.createElement('div');
        typingEl.className = 'message assistant';
        typingEl.innerHTML = `
          <div class="message-avatar">AI</div>
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        `;
        chatMessages.appendChild(typingEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return typingEl;
      }

      function showError(message) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = message;
        chatMessages.appendChild(errorEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        setTimeout(() => errorEl.remove(), 10000);
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Initialize
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
{% endblock %}
