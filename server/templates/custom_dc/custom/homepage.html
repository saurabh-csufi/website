{#
 Copyright 2023 Google LLC

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
#}

{%- extends BASE_HTML -%}

{% set main_id = 'homepage' %}
{% set page_id = 'page-homepage' %}

{% block head %}
  {{ super() }}
  <style>
    /* Chat Interface Styles */
    .gemini-chat-container {
      max-width: 900px;
      margin: 0 auto;
      padding: 20px;
      height: calc(100vh - 200px);
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      text-align: center;
      margin-bottom: 20px;
    }

    .chat-header h1 {
      font-size: 1.75rem;
      color: #1a1a2e;
      margin-bottom: 8px;
    }

    .chat-header p {
      color: #666;
      font-size: 0.95rem;
    }

    .config-section {
      background: #fff3cd;
      border: 1px solid #ffc107;
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 16px;
    }

    .config-section.hidden {
      display: none;
    }

    .config-row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
      margin-bottom: 12px;
    }

    .config-row:last-child {
      margin-bottom: 0;
    }

    .config-section label {
      font-weight: 500;
      color: #856404;
      white-space: nowrap;
      min-width: 120px;
    }

    .config-section input[type="password"],
    .config-section input[type="text"] {
      flex: 1;
      min-width: 200px;
      padding: 8px 12px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-family: monospace;
    }

    .config-section button {
      background: #ffc107;
      color: #856404;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
    }

    .config-section button:hover {
      background: #e0a800;
    }

    .config-status {
      width: 100%;
      font-size: 0.85rem;
      color: #856404;
      margin-top: 8px;
    }

    .config-status.success {
      color: #155724;
    }

    .config-status.error {
      color: #721c24;
    }

    .mcp-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .mcp-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .mcp-status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 0.8rem;
      font-weight: 500;
    }

    .mcp-status.connected {
      background: #d4edda;
      color: #155724;
    }

    .mcp-status.disconnected {
      background: #f8d7da;
      color: #721c24;
    }

    .mcp-status.checking {
      background: #fff3cd;
      color: #856404;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      margin-bottom: 16px;
      min-height: 300px;
    }

    .message {
      margin-bottom: 16px;
      display: flex;
      gap: 12px;
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: #4285f4;
      color: white;
    }

    .message.assistant .message-avatar {
      background: #34a853;
      color: white;
    }

    .message-content {
      max-width: 75%;
      padding: 12px 16px;
      border-radius: 12px;
      line-height: 1.5;
    }

    .message.user .message-content {
      background: #4285f4;
      color: white;
      border-bottom-right-radius: 4px;
    }

    .message.assistant .message-content {
      background: white;
      color: #1a1a2e;
      border-bottom-left-radius: 4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    }

    .message-content p {
      margin: 0 0 8px 0;
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content pre {
      background: #f1f3f4;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      margin: 8px 0;
    }

    .message-content code {
      font-family: 'Monaco', 'Menlo', monospace;
      font-size: 0.9em;
    }

    .tool-call-indicator {
      background: #e8f0fe;
      border: 1px solid #4285f4;
      border-radius: 8px;
      padding: 10px 14px;
      margin: 8px 0;
      font-size: 0.85rem;
      color: #1a73e8;
    }

    .tool-call-indicator.loading {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .tool-call-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      margin-bottom: 6px;
    }

    .tool-call-args {
      color: #5f6368;
      font-family: monospace;
      font-size: 0.8rem;
      background: rgba(255,255,255,0.5);
      padding: 6px 10px;
      border-radius: 4px;
      word-break: break-all;
    }

    .tool-call-result {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid rgba(66, 133, 244, 0.3);
      color: #1e8e3e;
      font-size: 0.8rem;
    }

    .tool-call-result.error {
      color: #d93025;
    }

    .chat-input-area {
      background: white;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      padding: 16px;
    }

    .file-upload-area {
      margin-bottom: 12px;
    }

    .file-drop-zone {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .file-drop-zone:hover,
    .file-drop-zone.drag-over {
      border-color: #4285f4;
      background: #f0f7ff;
    }

    .file-drop-zone input[type="file"] {
      display: none;
    }

    .file-drop-zone .drop-icon {
      font-size: 32px;
      margin-bottom: 8px;
    }

    .file-drop-zone .drop-text {
      color: #666;
      font-size: 0.9rem;
    }

    .file-drop-zone .drop-text span {
      color: #4285f4;
      font-weight: 500;
    }

    .uploaded-files {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-top: 12px;
    }

    .uploaded-file {
      display: flex;
      align-items: center;
      gap: 8px;
      background: #e8f0fe;
      padding: 8px 12px;
      border-radius: 20px;
      font-size: 0.85rem;
    }

    .uploaded-file .file-icon {
      color: #4285f4;
    }

    .uploaded-file .remove-file {
      cursor: pointer;
      color: #666;
      font-size: 16px;
    }

    .uploaded-file .remove-file:hover {
      color: #d93025;
    }

    .chat-input-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .chat-input-wrapper {
      flex: 1;
    }

    #chat-input {
      width: 100%;
      border: 1px solid #ddd;
      border-radius: 24px;
      padding: 12px 20px;
      font-size: 1rem;
      resize: none;
      min-height: 48px;
      max-height: 150px;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s;
    }

    #chat-input:focus {
      border-color: #4285f4;
    }

    #chat-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    #send-btn {
      background: #4285f4;
      color: white;
      border: none;
      border-radius: 50%;
      width: 48px;
      height: 48px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }

    #send-btn:hover:not(:disabled) {
      background: #3367d6;
    }

    #send-btn:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    #send-btn svg {
      width: 20px;
      height: 20px;
    }

    .typing-indicator {
      display: flex;
      gap: 4px;
      padding: 12px 16px;
    }

    .typing-indicator span {
      width: 8px;
      height: 8px;
      background: #666;
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); }
      30% { transform: translateY(-8px); }
    }

    .welcome-message {
      text-align: center;
      padding: 40px 20px;
      color: #666;
    }

    .welcome-message h2 {
      color: #1a1a2e;
      margin-bottom: 12px;
    }

    .welcome-message .suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-top: 20px;
    }

    .welcome-message .suggestion {
      background: white;
      border: 1px solid #ddd;
      border-radius: 20px;
      padding: 8px 16px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
    }

    .welcome-message .suggestion:hover:not(:disabled) {
      border-color: #4285f4;
      background: #f0f7ff;
    }

    .welcome-message .suggestion:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .error-message {
      background: #fce8e6;
      color: #d93025;
      padding: 12px 16px;
      border-radius: 8px;
      margin-bottom: 16px;
    }

    @media (max-width: 768px) {
      .gemini-chat-container {
        padding: 10px;
        height: calc(100vh - 150px);
      }

      .message-content {
        max-width: 85%;
      }

      .chat-header h1 {
        font-size: 1.5rem;
      }

      .config-row {
        flex-direction: column;
        align-items: stretch;
      }

      .config-section input {
        width: 100%;
      }

      .config-section label {
        min-width: auto;
      }
    }
  </style>
{% endblock %}

{% block content %}
  <div class="gemini-chat-container">
    <div class="chat-header">
      <h1>Data Commons AI Assistant</h1>
      <p>Ask about statistics, policies, or search through the knowledge base - powered by Gemini AI + Data Commons MCP + File Search</p>
    </div>

    <div style="text-align: right; margin-bottom: 8px;">
      <button type="button" id="toggle-config-btn" style="background: #6c757d; color: white; font-size: 0.8rem; padding: 4px 10px; border: none; border-radius: 4px; cursor: pointer;">Hide Settings</button>
    </div>

    <div class="config-section" id="config-section">
      <div class="config-row">
        <label for="api-key-input">Gemini API Key:</label>
        <input type="text" id="api-key-input" placeholder="Enter your Gemini API key">
      </div>

      <div class="config-row">
        <label for="mcp-url-input">MCP Proxy URL:</label>
        <input type="text" id="mcp-url-input" placeholder="http://localhost:5001" value="http://localhost:5001">
        <div class="mcp-toggle">
          <input type="checkbox" id="mcp-enabled" checked>
          <label for="mcp-enabled">Use MCP Tools</label>
        </div>
        <span class="mcp-status disconnected" id="mcp-status">Disconnected</span>
      </div>

      <div class="config-row">
        <label for="kb-store-input">Knowledge Base:</label>
        <input type="text" id="kb-store-input" placeholder="fileSearchStores/your-store-id" value="fileSearchStores/msmepolicies-8pibj9lwmrws">
        <div class="mcp-toggle">
          <input type="checkbox" id="kb-enabled" checked>
          <label for="kb-enabled">Use Knowledge Base</label>
        </div>
        <span class="mcp-status disconnected" id="kb-status">Ready</span>
      </div>

      <div class="config-row">
        <button id="save-config">Save & Connect</button>
      </div>

      <div class="config-status" id="config-status">
        Get Gemini key from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>.
        Run MCP proxy: <code>python additional_features/mcp_proxy_server.py</code>
      </div>
    </div>

    <div class="chat-messages" id="chat-messages">
      <div class="welcome-message" id="welcome-message">
        <h2>How can I help you today?</h2>
        <p>Configure your settings above, then ask questions about data or upload documents</p>
        <div class="suggestions">
          <button class="suggestion" data-text="What is the population of California?" disabled>Population of California</button>
          <button class="suggestion" data-text="What is the GDP of Germany?" disabled>GDP of Germany</button>
          <button class="suggestion" data-text="What are the key MSME policies in India?" disabled>MSME Policies (KB)</button>
        </div>
      </div>
    </div>

    <div class="chat-input-area">
      <div class="file-upload-area">
        <div class="file-drop-zone" id="file-drop-zone">
          <div class="drop-icon">ðŸ“„</div>
          <div class="drop-text">
            Drag & drop PDF files here or <span>browse</span>
          </div>
          <input type="file" id="file-input" accept=".pdf" multiple>
        </div>
        <div class="uploaded-files" id="uploaded-files"></div>
      </div>

      <div class="chat-input-row">
        <div class="chat-input-wrapper">
          <textarea
            id="chat-input"
            placeholder="Configure settings first..."
            rows="1"
            disabled
          ></textarea>
        </div>
        <button id="send-btn" title="Send message" disabled>
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
          </svg>
        </button>
      </div>
    </div>
  </div>

  <script>
    (function() {
      // Configuration
      const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta/models';

      // State
      let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
      let mcpProxyUrl = localStorage.getItem('mcp_proxy_url') || 'http://localhost:5001';
      let mcpEnabled = localStorage.getItem('mcp_enabled') !== 'false';
      let kbStoreId = localStorage.getItem('kb_store_id') || 'fileSearchStores/msmepolicies-8pibj9lwmrws';
      let kbEnabled = localStorage.getItem('kb_enabled') !== 'false';
      let mcpTools = [];
      let mcpConnected = false;
      let uploadedFiles = [];
      let conversationHistory = [];
      let isProcessing = false;

      // DOM Elements
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const fileInput = document.getElementById('file-input');
      const fileDropZone = document.getElementById('file-drop-zone');
      const uploadedFilesContainer = document.getElementById('uploaded-files');
      const welcomeMessage = document.getElementById('welcome-message');
      const configSection = document.getElementById('config-section');
      const apiKeyInput = document.getElementById('api-key-input');
      const mcpUrlInput = document.getElementById('mcp-url-input');
      const mcpEnabledCheckbox = document.getElementById('mcp-enabled');
      const mcpStatusEl = document.getElementById('mcp-status');
      const kbStoreInput = document.getElementById('kb-store-input');
      const kbEnabledCheckbox = document.getElementById('kb-enabled');
      const kbStatusEl = document.getElementById('kb-status');
      const saveConfigBtn = document.getElementById('save-config');
      const configStatus = document.getElementById('config-status');
      const toggleConfigBtn = document.getElementById('toggle-config-btn');

      // Models - use different models for different purposes
      const MCP_MODEL = 'gemini-2.0-flash';  // For MCP function calling (proven to work)
      const KB_MODEL = 'gemini-2.5-flash';   // For file search (requires 2.5)

      // System instructions
      const mcpSystemInstruction = `You are a Data Commons AI assistant with access to real-time statistical data tools.

CRITICAL: When users ask about ANY statistics, data, numbers, demographics, economics, health, environment, population, GDP, unemployment, or similar quantitative information:
1. You MUST use the available tools to fetch real data - NEVER make up numbers or provide code examples
2. First call search_indicators to find the right variable DCID for the query
3. Then call get_observations with the variable and place DCIDs to get actual data
4. Present the data clearly with the actual numbers and dates from the tool response

Tool workflow for data queries:
- Step 1: search_indicators(query="population", places=["California, USA"]) -> get variable DCID
- Step 2: get_observations(variable_dcid="...", place_dcid="...") -> get actual data
- Step 3: Present the numbers from the response

DO NOT generate Python code or tell users how to query - use the tools yourself and return the actual data.
Be concise but comprehensive. Cite "Data Commons" as the source when presenting data.`;

      const kbSystemInstruction = `You are a helpful assistant that answers questions based on the uploaded policy documents.
Always cite which document your information comes from.
If the answer is not found in the documents, say "No relevant information found in knowledge base."
Be concise and factual.`;

      // Initialize
      function init() {
        // Load saved config
        if (geminiApiKey) apiKeyInput.value = geminiApiKey;
        if (mcpProxyUrl) mcpUrlInput.value = mcpProxyUrl;
        mcpEnabledCheckbox.checked = mcpEnabled;
        if (kbStoreId) kbStoreInput.value = kbStoreId;
        kbEnabledCheckbox.checked = kbEnabled;

        // Event listeners
        saveConfigBtn.addEventListener('click', saveConfig);
        toggleConfigBtn.addEventListener('click', () => {
          const isHidden = configSection.classList.toggle('hidden');
          toggleConfigBtn.textContent = isHidden ? 'Show Settings' : 'Hide Settings';
        });
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', handleKeyDown);
        chatInput.addEventListener('input', autoResize);
        fileInput.addEventListener('change', handleFileSelect);
        fileDropZone.addEventListener('click', () => fileInput.click());
        fileDropZone.addEventListener('dragover', handleDragOver);
        fileDropZone.addEventListener('dragleave', handleDragLeave);
        fileDropZone.addEventListener('drop', handleDrop);

        // Suggestion buttons
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.addEventListener('click', () => {
            if (!btn.disabled) {
              chatInput.value = btn.dataset.text;
              sendMessage();
            }
          });
        });

        // Auto-connect if config exists
        if (geminiApiKey) {
          saveConfig();
        }
      }

      // Save configuration and connect
      async function saveConfig() {
        const key = apiKeyInput.value.trim();
        const url = mcpUrlInput.value.trim();
        const enabled = mcpEnabledCheckbox.checked;
        const kbStore = kbStoreInput.value.trim();
        const kbOn = kbEnabledCheckbox.checked;

        if (!key) {
          configStatus.textContent = 'Please enter a Gemini API key';
          configStatus.className = 'config-status error';
          return;
        }

        geminiApiKey = key;
        mcpProxyUrl = url;
        mcpEnabled = enabled;
        kbStoreId = kbStore;
        kbEnabled = kbOn;

        localStorage.setItem('gemini_api_key', key);
        localStorage.setItem('mcp_proxy_url', url);
        localStorage.setItem('mcp_enabled', enabled.toString());
        localStorage.setItem('kb_store_id', kbStore);
        localStorage.setItem('kb_enabled', kbOn.toString());

        configStatus.textContent = 'Connecting...';
        configStatus.className = 'config-status';

        // Check MCP connection if enabled
        if (mcpEnabled && url) {
          mcpStatusEl.textContent = 'Checking...';
          mcpStatusEl.className = 'mcp-status checking';

          const connected = await checkMcpConnection();
          if (connected) {
            mcpConnected = true;
            mcpStatusEl.textContent = `Connected (${mcpTools.length} tools)`;
            mcpStatusEl.className = 'mcp-status connected';
          } else {
            mcpConnected = false;
            mcpStatusEl.textContent = 'Disconnected';
            mcpStatusEl.className = 'mcp-status disconnected';
          }
        } else {
          mcpConnected = false;
          mcpStatusEl.textContent = 'Disabled';
          mcpStatusEl.className = 'mcp-status disconnected';
        }

        // Update knowledge base status
        if (kbEnabled && kbStoreId) {
          kbStatusEl.textContent = 'Enabled';
          kbStatusEl.className = 'mcp-status connected';
        } else {
          kbStatusEl.textContent = 'Disabled';
          kbStatusEl.className = 'mcp-status disconnected';
        }

        enableChat();
        configStatus.textContent = 'Configuration saved! You can now start chatting.';
        configStatus.className = 'config-status success';

        // Don't auto-hide - let user control via toggle button
      }

      // Check MCP proxy connection and fetch tools
      async function checkMcpConnection() {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/tools`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });

          if (!response.ok) return false;

          const data = await response.json();
          if (data.success && data.tools) {
            mcpTools = data.tools;
            console.log('MCP Tools loaded:', mcpTools.map(t => t.name));
            return true;
          }
          return false;
        } catch (err) {
          console.error('MCP connection error:', err);
          return false;
        }
      }

      // Execute MCP tool call
      async function executeMcpToolCall(name, args) {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/call`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, arguments: args })
          });

          const data = await response.json();

          if (data.success && data.result) {
            // Extract text content from MCP result
            const content = data.result.content;
            if (Array.isArray(content)) {
              return content.map(c => c.text || JSON.stringify(c)).join('\n');
            }
            return JSON.stringify(data.result);
          }

          return JSON.stringify({ error: data.error || 'Unknown error' });
        } catch (err) {
          console.error('MCP tool call error:', err);
          return JSON.stringify({ error: err.message });
        }
      }

      function enableChat() {
        chatInput.disabled = false;
        chatInput.placeholder = mcpConnected
          ? 'Ask about data, statistics, or upload documents...'
          : 'Ask questions or upload documents...';
        sendBtn.disabled = false;
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.disabled = false;
        });
      }

      // Auto-resize textarea
      function autoResize() {
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';
      }

      function handleKeyDown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      }

      // File handling
      function handleDragOver(e) {
        e.preventDefault();
        fileDropZone.classList.add('drag-over');
      }

      function handleDragLeave(e) {
        e.preventDefault();
        fileDropZone.classList.remove('drag-over');
      }

      function handleDrop(e) {
        e.preventDefault();
        fileDropZone.classList.remove('drag-over');
        const files = Array.from(e.dataTransfer.files).filter(f => f.type === 'application/pdf');
        processFiles(files);
      }

      function handleFileSelect(e) {
        const files = Array.from(e.target.files);
        processFiles(files);
        e.target.value = '';
      }

      async function processFiles(files) {
        for (const file of files) {
          if (file.size > 20 * 1024 * 1024) {
            showError(`File "${file.name}" is too large. Maximum size is 20MB.`);
            continue;
          }

          try {
            const base64 = await fileToBase64(file);
            uploadedFiles.push({
              name: file.name,
              data: base64,
              mimeType: 'application/pdf'
            });
            renderUploadedFiles();
          } catch (err) {
            showError(`Failed to process "${file.name}"`);
          }
        }
      }

      function fileToBase64(file) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
      }

      function renderUploadedFiles() {
        uploadedFilesContainer.innerHTML = uploadedFiles.map((file, index) => `
          <div class="uploaded-file">
            <span class="file-icon">ðŸ“„</span>
            <span class="file-name">${escapeHtml(file.name)}</span>
            <span class="remove-file" data-index="${index}">&times;</span>
          </div>
        `).join('');

        document.querySelectorAll('.remove-file').forEach(btn => {
          btn.addEventListener('click', (e) => {
            const index = parseInt(e.target.dataset.index);
            uploadedFiles.splice(index, 1);
            renderUploadedFiles();
          });
        });
      }

      // Show tool call in UI
      function showToolCall(name, args) {
        const toolEl = document.createElement('div');
        toolEl.className = 'tool-call-indicator loading';
        toolEl.innerHTML = `
          <div class="tool-call-header">
            <span>ðŸ”§</span>
            <span>${escapeHtml(name)}</span>
          </div>
          <div class="tool-call-args">${escapeHtml(JSON.stringify(args, null, 2))}</div>
          <div class="tool-call-result"></div>
        `;
        chatMessages.appendChild(toolEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return toolEl;
      }

      function updateToolCallResult(toolEl, result, isError = false) {
        toolEl.classList.remove('loading');
        const resultEl = toolEl.querySelector('.tool-call-result');
        resultEl.className = `tool-call-result${isError ? ' error' : ''}`;

        // Truncate long results
        let displayResult = result;
        if (result.length > 500) {
          displayResult = result.substring(0, 500) + '... (truncated)';
        }
        resultEl.textContent = displayResult;
      }

      // ============================================================
      // PHASE 1: MCP Tools Query (using gemini-2.0-flash)
      // This is the EXACT logic from the old working implementation
      // ============================================================
      async function queryWithMcpTools(userMessage, documentData = null) {
        if (!mcpConnected || mcpTools.length === 0) {
          console.log('MCP not connected or no tools available');
          return { success: false, response: null, error: 'MCP not connected' };
        }

        console.log('=== Starting MCP Query ===');
        console.log(`MCP Tools available: ${mcpTools.map(t => t.name).join(', ')}`);

        try {
          // Build contents
          const contents = [];
          const currentParts = [];

          if (documentData) {
            currentParts.push({
              inline_data: {
                mime_type: documentData.mimeType,
                data: documentData.data
              }
            });
          }

          currentParts.push({ text: userMessage });
          contents.push({ role: 'user', parts: currentParts });

          // Function calling loop (exact copy from old working code)
          let maxIterations = 5;
          let iteration = 0;

          while (iteration < maxIterations) {
            iteration++;

            // Build payload
            const payload = {
              contents: contents,
              systemInstruction: { parts: [{ text: mcpSystemInstruction }] },
              generationConfig: {
                temperature: 0.7,
                topP: 0.95,
                topK: 40
              }
            };

            // Add tools if MCP is connected (exact logic from old code)
            const dataKeywords = /population|gdp|unemployment|rate|statistics|data|how many|what is the|number of|percent|average|median|income|health|economy|demographics|emissions|climate|crime|education/i;
            const isDataQuery = dataKeywords.test(userMessage);

            if (iteration >= 3) {
              // Don't include tools - force pure text response
              console.log(`MCP Iteration ${iteration}: Forcing text response (no tools)`);
            } else {
              // Simplify tool descriptions for Gemini
              const simplifiedTools = mcpTools.map(t => ({
                name: t.name,
                description: t.description.length > 500
                  ? t.description.substring(0, 500) + '...'
                  : t.description,
                parameters: t.parameters
              }));
              payload.tools = [{ functionDeclarations: simplifiedTools }];

              const mode = (iteration === 1 && isDataQuery) ? 'ANY' : 'AUTO';
              console.log(`MCP Iteration ${iteration}: Using mode ${mode}`);
              payload.toolConfig = {
                functionCallingConfig: { mode: mode }
              };
            }

            // Call Gemini with MCP_MODEL (2.0-flash)
            console.log('MCP Request payload:', JSON.stringify(payload, null, 2));

            const response = await fetch(
              `${GEMINI_API_BASE}/${MCP_MODEL}:generateContent?key=${geminiApiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              }
            );

            const data = await response.json();
            console.log('MCP Response:', JSON.stringify(data, null, 2));

            if (data.error) {
              throw new Error(data.error.message || 'MCP API request failed');
            }

            const candidates = data.candidates || [];
            if (candidates.length === 0) {
              throw new Error('No response from MCP query');
            }

            const responseParts = candidates[0].content?.parts || [];
            const functionCalls = responseParts.filter(p => p.functionCall);

            if (functionCalls.length > 0 && mcpConnected) {
              // Add model response to conversation
              contents.push({ role: 'model', parts: responseParts });

              // Execute tool calls
              const functionResponses = [];
              for (const part of functionCalls) {
                const fc = part.functionCall;
                console.log(`Executing MCP tool: ${fc.name}`, fc.args);

                // Show tool call in UI
                const toolEl = showToolCall(fc.name, fc.args);

                try {
                  const result = await executeMcpToolCall(fc.name, fc.args);
                  updateToolCallResult(toolEl, result, false);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { result: result }
                    }
                  });
                } catch (err) {
                  updateToolCallResult(toolEl, err.message, true);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { error: err.message }
                    }
                  });
                }
              }

              // Add function responses
              contents.push({ role: 'user', parts: functionResponses });

            } else {
              // Got text response
              const textParts = responseParts.filter(p => p.text);
              if (textParts.length > 0) {
                const response = textParts.map(p => p.text).join('\n');
                console.log('MCP Query successful');
                return { success: true, response: response, error: null };
              }
              break;
            }
          }

          return { success: false, response: null, error: 'MCP query did not produce response' };

        } catch (err) {
          console.error('MCP Query error:', err);
          return { success: false, response: null, error: err.message };
        }
      }

      // ============================================================
      // PHASE 2: Knowledge Base Query (using gemini-2.5-flash)
      // Separate API call for file search
      // ============================================================
      async function queryWithKnowledgeBase(userMessage) {
        if (!kbEnabled || !kbStoreId) {
          console.log('Knowledge base not enabled or no store ID');
          return { success: false, response: null, sources: [], error: 'KB not configured' };
        }

        console.log('=== Starting Knowledge Base Query ===');
        console.log(`KB Store: ${kbStoreId}`);

        try {
          const payload = {
            contents: [{ role: 'user', parts: [{ text: userMessage }] }],
            systemInstruction: { parts: [{ text: kbSystemInstruction }] },
            tools: [{
              fileSearch: {
                fileSearchStoreNames: [kbStoreId]
              }
            }],
            generationConfig: {
              temperature: 0.3,
              topP: 0.95,
              topK: 40
            }
          };

          console.log('KB Request payload:', JSON.stringify(payload, null, 2));

          const response = await fetch(
            `${GEMINI_API_BASE}/${KB_MODEL}:generateContent?key=${geminiApiKey}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }
          );

          const data = await response.json();
          console.log('KB Response:', JSON.stringify(data, null, 2));

          if (data.error) {
            throw new Error(data.error.message || 'KB API request failed');
          }

          const candidates = data.candidates || [];
          if (candidates.length === 0) {
            return { success: false, response: null, sources: [], error: 'No KB response' };
          }

          const responseParts = candidates[0].content?.parts || [];
          const textParts = responseParts.filter(p => p.text);
          const responseText = textParts.map(p => p.text).join('\n');

          // Extract sources from grounding metadata
          const sources = [];
          const groundingMetadata = candidates[0].groundingMetadata;
          if (groundingMetadata && groundingMetadata.groundingChunks) {
            groundingMetadata.groundingChunks
              .filter(chunk => chunk.retrievedContext)
              .forEach(chunk => {
                const source = chunk.retrievedContext.title || chunk.retrievedContext.uri;
                if (source && !sources.includes(source)) {
                  sources.push(source);
                }
              });
          }

          console.log('KB Query successful, sources:', sources);
          return { success: true, response: responseText, sources: sources, error: null };

        } catch (err) {
          console.error('KB Query error:', err);
          return { success: false, response: null, sources: [], error: err.message };
        }
      }

      // ============================================================
      // MAIN: Send message - calls BOTH MCP and KB, combines results
      // ============================================================
      async function sendMessage() {
        const message = chatInput.value.trim();
        if ((!message && uploadedFiles.length === 0) || isProcessing || !geminiApiKey) return;

        // Hide welcome message
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }

        // Show user message
        let displayMessage = message;
        if (uploadedFiles.length > 0) {
          const fileNames = uploadedFiles.map(f => f.name).join(', ');
          displayMessage = message ? `ðŸ“„ ${fileNames}\n\n${message}` : `ðŸ“„ Uploaded: ${fileNames}`;
        }
        addMessage('user', displayMessage);

        // Clear input
        chatInput.value = '';
        autoResize();

        // Start processing
        isProcessing = true;
        sendBtn.disabled = true;
        chatInput.disabled = true;
        const typingEl = showTypingIndicator();

        const userMessage = message || 'Please analyze this document and provide a summary.';
        const documentData = uploadedFiles.length > 0 ? uploadedFiles[0] : null;

        try {
          console.log('=== Processing Query ===');
          console.log(`User message: ${userMessage}`);
          console.log(`MCP connected: ${mcpConnected}, Tools: ${mcpTools.length}`);
          console.log(`KB enabled: ${kbEnabled}, Store: ${kbStoreId}`);

          // Run BOTH queries in parallel
          const [mcpResult, kbResult] = await Promise.all([
            queryWithMcpTools(userMessage, documentData),
            queryWithKnowledgeBase(userMessage)
          ]);

          console.log('MCP Result:', mcpResult);
          console.log('KB Result:', kbResult);

          // Remove typing indicator
          typingEl.remove();

          // Combine results
          let finalResponse = '';
          let hasContent = false;

          // Add MCP response (Data Commons data)
          if (mcpResult.success && mcpResult.response) {
            finalResponse += mcpResult.response;
            hasContent = true;
          }

          // Add KB response (Policy documents)
          if (kbResult.success && kbResult.response) {
            // Check if KB found relevant info (not just "no information found")
            const noInfoPatterns = /no relevant information|not found in|cannot find|no information available/i;
            if (!noInfoPatterns.test(kbResult.response)) {
              if (hasContent) {
                finalResponse += '\n\n---\n\n**From Knowledge Base:**\n';
              }
              finalResponse += kbResult.response;
              hasContent = true;

              // Add sources
              if (kbResult.sources && kbResult.sources.length > 0) {
                finalResponse += '\n\n**Sources:**\n' + kbResult.sources.map(s => `â€¢ ${s}`).join('\n');
              }
            }
          }

          // If neither worked, show error info
          if (!hasContent) {
            if (mcpResult.error && kbResult.error) {
              finalResponse = `I couldn't retrieve information from either source.\n\nMCP: ${mcpResult.error}\nKnowledge Base: ${kbResult.error}`;
            } else if (mcpResult.error) {
              finalResponse = `Data Commons query failed: ${mcpResult.error}`;
            } else if (kbResult.error) {
              finalResponse = `Knowledge Base query failed: ${kbResult.error}`;
            } else {
              finalResponse = 'No relevant information found.';
            }
          }

          // Display response
          addMessage('assistant', finalResponse);

          // Update conversation history
          conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
          conversationHistory.push({ role: 'model', parts: [{ text: finalResponse }] });

          // Clear files
          uploadedFiles = [];
          renderUploadedFiles();

        } catch (err) {
          typingEl.remove();
          console.error('Chat error:', err);

          if (err.message.includes('API key')) {
            showError('Invalid API key. Please check your Gemini API key.');
            configSection.classList.remove('hidden');
          } else {
            showError(`Error: ${err.message}`);
          }
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          chatInput.disabled = false;
          chatInput.focus();
        }
      }

      // UI helpers
      function addMessage(role, content) {
        const messageEl = document.createElement('div');
        messageEl.className = `message ${role}`;

        const avatar = role === 'user' ? 'U' : 'AI';
        const formattedContent = formatMessage(content);

        messageEl.innerHTML = `
          <div class="message-avatar">${avatar}</div>
          <div class="message-content">${formattedContent}</div>
        `;

        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      function formatMessage(content) {
        let formatted = escapeHtml(content);
        formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
        formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        formatted = formatted.replace(/\n/g, '<br>');
        return formatted;
      }

      function showTypingIndicator() {
        const typingEl = document.createElement('div');
        typingEl.className = 'message assistant';
        typingEl.innerHTML = `
          <div class="message-avatar">AI</div>
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        `;
        chatMessages.appendChild(typingEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return typingEl;
      }

      function showError(message) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = message;
        chatMessages.appendChild(errorEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        setTimeout(() => errorEl.remove(), 10000);
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Initialize
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
{% endblock %}
