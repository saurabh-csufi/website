{#
  Copyright 2023 Google LLC

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
#}

{%- extends BASE_HTML -%}

{% set main_id = 'homepage' %}
{% set page_id = 'page-homepage' %}

{% block head %}
  {{ super() }}
  <style>
    /* Government of India - MSME Portal Styles */
    :root {
      --gov-blue: #003366;
      --gov-blue-light: #004080;
      --gov-blue-dark: #001a33;
      --saffron: #FF9933;
      --white: #FFFFFF;
      --green: #138808;
      --chakra-blue: #000080;
      --text-dark: #1a1a2e;
      --text-muted: #5f6368;
      --bg-light: #f5f7fa;
      --border-color: #dee2e6;
      --success: #28a745;
      --warning: #ffc107;
      --danger: #dc3545;
    }

    * {
      box-sizing: border-box;
    }

    /* Full Page Layout - 3 Column */
    #homepage {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 70px);
      padding: 0;
      overflow: hidden;
    }

    /* App Container - 3 columns */
    .app-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Left Sidebar - Tool Calls */
    .left-sidebar {
      width: 320px;
      background: #f8f9fa;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px;
      background: var(--gov-blue);
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .sidebar-header svg {
      flex-shrink: 0;
    }

    .sidebar-close {
      margin-left: auto;
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }

    .tool-calls-container {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .tool-calls-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .tool-call-item {
      background: white;
      border: 1px solid var(--border-color);
      border-left: 3px solid var(--gov-blue);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
      font-size: 0.8rem;
    }

    .tool-call-item.loading {
      border-left-color: var(--saffron);
      animation: pulse 1.5s infinite;
    }

    .tool-call-item.success {
      border-left-color: var(--green);
    }

    .tool-call-item.error {
      border-left-color: var(--danger);
    }

    .tool-call-name {
      font-weight: 600;
      color: var(--gov-blue);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tool-call-name .badge {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 10px;
      background: var(--saffron);
      color: white;
      font-weight: 500;
    }

    .tool-call-args {
      background: #f1f3f4;
      padding: 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.7rem;
      word-break: break-all;
      margin-bottom: 8px;
      max-height: 80px;
      overflow-y: auto;
    }

    .tool-call-result {
      color: var(--text-muted);
      font-size: 0.75rem;
      max-height: 100px;
      overflow-y: auto;
    }

    .tool-call-result.success {
      color: var(--green);
    }

    .tool-call-result.error {
      color: var(--danger);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      overflow: hidden;
    }

    /* Right Sidebar - Settings */
    .right-sidebar {
      width: 320px;
      background: white;
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      transform: translateX(0);
      transition: transform 0.3s ease;
    }

    .right-sidebar.hidden {
      transform: translateX(100%);
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      z-index: 100;
      box-shadow: -4px 0 20px rgba(0,0,0,0.1);
    }

    .right-sidebar .settings-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .config-section {
      margin-bottom: 20px;
    }

    .config-section label {
      display: block;
      font-weight: 600;
      font-size: 0.8rem;
      color: var(--gov-blue);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .config-section input[type="text"],
    .config-section input[type="password"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.85rem;
      font-family: inherit;
    }

    .config-section input:focus {
      outline: none;
      border-color: var(--gov-blue);
      box-shadow: 0 0 0 3px rgba(0, 51, 102, 0.1);
    }

    .config-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
    }

    .config-toggle span:first-child {
      flex: 1;
      font-size: 0.85rem;
      color: var(--text-dark);
    }

    .status-badge {
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 12px;
      background: #dc3545;
      color: white;
      font-weight: 500;
    }

    .status-badge.active {
      background: var(--green);
    }

    /* Toggle Switch */
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: var(--gov-blue);
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    .btn-primary {
      width: 100%;
      background: var(--gov-blue);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
      margin-top: 10px;
    }

    .btn-primary:hover {
      background: var(--gov-blue-light);
    }

    .config-status {
      text-align: center;
      margin-top: 10px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .config-help {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border-color);
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .config-help p {
      margin: 0 0 8px 0;
    }

    .config-help a {
      color: var(--gov-blue);
      text-decoration: none;
    }

    .config-help a:hover {
      text-decoration: underline;
    }

    .config-help code {
      background: #e9ecef;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.7rem;
      word-break: break-all;
    }

    /* Settings FAB */
    .settings-fab {
      display: none;
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 56px;
      height: 56px;
      border-radius: 50%;
      background: var(--gov-blue);
      color: white;
      border: none;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
      z-index: 99;
      align-items: center;
      justify-content: center;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .settings-fab:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 16px rgba(0,0,0,0.25);
    }

    .settings-fab.visible {
      display: flex;
    }

    /* Chat Area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      min-height: 400px;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
      min-height: 300px;
    }

    .message {
      margin-bottom: 20px;
      display: flex;
      gap: 12px;
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: var(--gov-blue);
      color: white;
    }

    .message.assistant .message-avatar {
      background: linear-gradient(135deg, var(--saffron) 0%, var(--green) 100%);
      color: white;
    }

    .message-content {
      max-width: 70%;
      padding: 14px 18px;
      border-radius: 12px;
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .message.user .message-content {
      background: var(--gov-blue);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .message.assistant .message-content {
      background: white;
      color: var(--text-dark);
      border-bottom-left-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      border: 1px solid #e9ecef;
    }

    .message-content p {
      margin: 0 0 10px 0;
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 14px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 10px 0;
      font-size: 0.85rem;
    }

    .message-content code {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.9em;
    }

    .message.user .message-content code {
      background: rgba(255,255,255,0.2);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .message.assistant .message-content code:not(pre code) {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 3px;
      color: var(--gov-blue);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Welcome Message */
    .welcome-message {
      text-align: center;
      padding: 60px 40px;
    }

    .welcome-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, var(--saffron) 0%, var(--green) 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 24px;
      font-size: 36px;
    }

    .welcome-message h2 {
      color: var(--gov-blue);
      margin: 0 0 12px 0;
      font-size: 1.5rem;
      font-weight: 600;
    }

    .welcome-message p {
      color: var(--text-muted);
      margin: 0 0 28px 0;
      font-size: 1rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .welcome-message .suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .welcome-message .suggestion {
      background: white;
      border: 2px solid var(--border-color);
      border-radius: 24px;
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
      color: var(--text-dark);
    }

    .welcome-message .suggestion:hover:not(:disabled) {
      border-color: var(--gov-blue);
      background: #f0f7ff;
      color: var(--gov-blue);
    }

    .welcome-message .suggestion:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Chat Input Area */
    .chat-input-area {
      background: white;
      border-top: 1px solid var(--border-color);
      padding: 16px 24px;
    }

    .chat-input-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .chat-input-wrapper {
      flex: 1;
    }

    #chat-input {
      width: 100%;
      border: 2px solid var(--border-color);
      border-radius: 24px;
      padding: 14px 22px;
      font-size: 1rem;
      resize: none;
      min-height: 52px;
      max-height: 150px;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      font-family: inherit;
    }

    #chat-input:focus {
      border-color: var(--gov-blue);
      box-shadow: 0 0 0 4px rgba(0, 51, 102, 0.1);
    }

    #chat-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    #send-btn {
      background: var(--gov-blue);
      color: white;
      border: none;
      border-radius: 50%;
      width: 52px;
      height: 52px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    #send-btn:hover:not(:disabled) {
      background: var(--gov-blue-light);
      transform: scale(1.05);
    }

    #send-btn:disabled {
      background: #adb5bd;
      cursor: not-allowed;
    }

    #send-btn svg {
      width: 22px;
      height: 22px;
    }

    /* Typing Indicator */
    .typing-indicator {
      display: flex;
      gap: 5px;
      padding: 14px 18px;
    }

    .typing-indicator span {
      width: 10px;
      height: 10px;
      background: var(--gov-blue);
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-10px); opacity: 1; }
    }

    /* Streaming cursor animation */
    .streaming-cursor {
      display: inline-block;
      animation: blink 0.8s infinite;
      color: var(--gov-blue);
      font-weight: normal;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Error Message */
    .error-message {
      background: #fdf2f2;
      color: var(--danger);
      padding: 14px 18px;
      border-radius: 8px;
      margin-bottom: 16px;
      border: 1px solid #fecaca;
      border-left: 4px solid var(--danger);
    }

    /* Google Data Commons Footer */
    .google-footer {
      background: #ffffff;
      border-top: 1px solid var(--border-color);
      padding: 16px 24px;
      text-align: center;
      margin-top: auto;
    }

    .google-footer-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .google-logo {
      display: inline-flex;
      align-items: center;
      font-weight: 500;
      letter-spacing: -0.5px;
    }

    .google-logo .g-blue { color: #4285F4; }
    .google-logo .g-red { color: #EA4335; }
    .google-logo .g-yellow { color: #FBBC05; }
    .google-logo .g-green { color: #34A853; }

    .google-footer a {
      color: #4285F4;
      text-decoration: none;
      font-weight: 500;
    }

    .google-footer a:hover {
      text-decoration: underline;
    }

    /* Responsive - 3 Column Layout */
    @media (max-width: 1200px) {
      .left-sidebar {
        width: 280px;
      }
      .right-sidebar {
        width: 280px;
      }
    }

    @media (max-width: 992px) {
      /* Hide left sidebar on tablets */
      .left-sidebar {
        display: none;
      }

      .message-content {
        max-width: 85%;
      }
    }

    @media (max-width: 768px) {
      #homepage {
        height: calc(100vh - 60px);
      }

      /* Hide both sidebars on mobile */
      .left-sidebar {
        display: none;
      }

      .right-sidebar {
        display: none;
      }

      .right-sidebar.visible {
        display: flex;
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
        width: 100%;
        max-width: 320px;
        z-index: 1000;
        box-shadow: -4px 0 20px rgba(0,0,0,0.15);
      }

      /* Show settings FAB on mobile */
      .settings-fab {
        display: flex;
      }

      .chat-messages {
        padding: 16px;
      }

      .message-content {
        max-width: 90%;
        padding: 12px 14px;
        font-size: 0.9rem;
      }

      .message-avatar {
        width: 32px;
        height: 32px;
        font-size: 12px;
      }

      .welcome-message {
        padding: 30px 16px;
      }

      .welcome-message h2 {
        font-size: 1.2rem;
      }

      .welcome-message p {
        font-size: 0.9rem;
      }

      .welcome-message .suggestions {
        flex-direction: column;
        align-items: stretch;
      }

      .welcome-message .suggestion {
        text-align: left;
        font-size: 0.85rem;
        padding: 12px 16px;
      }

      .chat-input-area {
        padding: 12px 16px;
      }

      #chat-input {
        padding: 12px 18px;
        font-size: 0.95rem;
        min-height: 46px;
      }

      #send-btn {
        width: 46px;
        height: 46px;
      }

      .google-footer {
        padding: 12px 16px;
      }

      .google-footer-content {
        font-size: 0.8rem;
        flex-wrap: wrap;
      }
    }

    @media (max-width: 480px) {
      .welcome-icon {
        width: 60px;
        height: 60px;
        font-size: 28px;
      }

      .tool-call-args {
        font-size: 0.75rem;
        padding: 6px 10px;
      }
    }

    /* Data Commons Chart Styles */
    .dc-chart-container {
      background: #ffffff;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
      min-height: 300px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

    .dc-chart-container.loading {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
    }

    .dc-chart-container.loading::after {
      content: 'Loading visualization...';
      animation: pulse 1.5s infinite;
    }

    .dc-chart-container datacommons-line,
    .dc-chart-container datacommons-bar,
    .dc-chart-container datacommons-map,
    .dc-chart-container datacommons-highlight {
      --dc-headings-font-family: inherit;
      --dc-font-family: inherit;
      width: 100%;
      min-height: 280px;
    }

    .message-content .dc-chart-container {
      max-width: 100%;
      overflow-x: auto;
    }

    .dc-chart-error {
      background: #fdf2f2;
      border: 1px solid #fecaca;
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
      color: var(--danger);
      font-size: 0.9rem;
    }

    .dc-chart-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--gov-blue);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--saffron);
    }

    .dc-chart-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border-color);
      font-size: 0.8rem;
      color: var(--text-muted);
      flex-wrap: wrap;
      gap: 8px;
    }

    .dc-chart-unit {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .dc-chart-source {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .dc-chart-source a {
      color: var(--gov-blue);
      text-decoration: none;
    }

    .dc-chart-source a:hover {
      text-decoration: underline;
    }
  </style>
{% endblock %}

{% block content %}
  <!-- App Container with 3-column layout -->
  <div class="app-container">
    <!-- Left Sidebar - Tool Calls -->
    <aside class="left-sidebar" id="left-sidebar">
      <div class="sidebar-header">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
        </svg>
        <span>Tool Activity</span>
      </div>
      <div class="tool-calls-container" id="tool-calls-container">
        <div class="tool-calls-empty">
          <p>Tool calls will appear here when you ask data questions</p>
        </div>
      </div>
    </aside>

    <!-- Main Chat Area -->
    <main class="main-content">
      <div class="chat-area">
        <div class="chat-messages" id="chat-messages">
          <div class="welcome-message" id="welcome-message">
            <div class="welcome-icon">VS</div>
            <h2>VYAPAR SAH<span style="color: var(--saffron);">(AI)</span></h2>
            <p>Your Intelligent Business Companion | आपका बुद्धिमान व्यापार सहायक</p>
            <div class="suggestions">
              <button class="suggestion" data-text="What are the export trends for fish products from India?" disabled>What are the export trends for fish products from India?</button>
              <button class="suggestion" data-text="What financial assistance is available under the PMEGP scheme for MSMEs?
              " disabled>What financial assistance is available under the PMEGP scheme for MSMEs?
            </button>
            <button class="suggestion" data-text="How can MSMEs avail duty-free import of capital goods?
            " disabled>How can MSMEs avail duty-free import of capital goods?
            </button>
            </div>
          </div>
        </div>

        <div class="chat-input-area">
          <div class="chat-input-row">
            <div class="chat-input-wrapper">
              <textarea
                id="chat-input"
                placeholder="Configure settings to start chatting..."
                rows="1"
                disabled
              ></textarea>
            </div>
            <button id="send-btn" title="Send message" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Google Data Commons Footer -->
      <footer class="google-footer">
        <div class="google-footer-content">
          <span>Powered by</span>
          <span class="google-logo">
            <span class="g-blue">G</span><span class="g-red">o</span><span class="g-yellow">o</span><span class="g-blue">g</span><span class="g-green">l</span><span class="g-red">e</span>
          </span>
          <a href="https://datacommons.org" target="_blank" rel="noopener">Data Commons</a>
        </div>
      </footer>
    </main>

    <!-- Right Sidebar - Settings -->
    <aside class="right-sidebar" id="right-sidebar">
      <div class="sidebar-header">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
        </svg>
        <span>Settings</span>
        <button class="sidebar-close" id="close-settings">×</button>
      </div>
      <div class="settings-content" id="settings-content">
        <div class="config-section">
          <label for="api-key-input">Gemini API Key</label>
          <input type="password" id="api-key-input" placeholder="Enter your Gemini API key">
        </div>

        <div class="config-section">
          <label for="mcp-url-input">MCP Proxy URL</label>
          <input type="text" id="mcp-url-input" placeholder="http://localhost:5001" value="http://localhost:5001">
          <div class="config-toggle">
            <span>MCP Tools</span>
            <span class="status-badge" id="mcp-status">Disconnected</span>
            <label class="switch">
              <input type="checkbox" id="mcp-enabled" checked>
              <span class="slider"></span>
            </label>
          </div>
        </div>

        <div class="config-section">
          <label for="kb-store-input">Knowledge Base</label>
          <input type="text" id="kb-store-input" placeholder="fileSearchStores/your-store-id" value="fileSearchStores/msmepolicies-8pibj9lwmrws">
          <div class="config-toggle">
            <span>Knowledge Base</span>
            <span class="status-badge active" id="kb-status">Active</span>
            <label class="switch">
              <input type="checkbox" id="kb-enabled" checked>
              <span class="slider"></span>
            </label>
          </div>
        </div>

        <button class="btn-primary" id="save-config">Save and Connect</button>
        <div class="config-status" id="config-status"></div>

        <div class="config-help">
          <!-- <p>Get Gemini key from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>.</p> -->
          <!-- <p>Run MCP proxy: <code>python additional_features/mcp_proxy_server.py</code></p> -->
        </div>
      </div>
    </aside>
  </div>

  <!-- Settings Toggle Button (floating) -->
  <button class="settings-fab" id="settings-fab" title="Open Settings">
    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="3"></circle>
      <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
    </svg>
  </button>

  <script>
    (function() {
      // Configuration
      const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta/models';

      // State
      let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
      let mcpProxyUrl = localStorage.getItem('mcp_proxy_url') || 'http://localhost:5001';
      let mcpEnabled = localStorage.getItem('mcp_enabled') !== 'false';
      let kbStoreId = localStorage.getItem('kb_store_id') || 'fileSearchStores/msmepolicies-8pibj9lwmrws';
      let kbEnabled = localStorage.getItem('kb_enabled') !== 'false';
      let mcpTools = [];
      let mcpConnected = false;
      let conversationHistory = [];
      let isProcessing = false;
      let lastChartAnalysis = null;
      let lastDataSource = null;  // Track the data source from MCP responses

      // Chart.js Script Loader
      let chartJsLoaded = false;
      let chartJsLoadPromise = null;

      function loadChartJs() {
        if (chartJsLoaded) return Promise.resolve();
        if (chartJsLoadPromise) return chartJsLoadPromise;

        chartJsLoadPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
          script.onload = () => {
            chartJsLoaded = true;
            console.log('Chart.js loaded');
            resolve();
          };
          script.onerror = () => reject(new Error('Failed to load Chart.js'));
          document.head.appendChild(script);
        });

        return chartJsLoadPromise;
      }

      // Chart Data Analyzer - extracts actual data from tool results for Chart.js
      function analyzeChartData(toolName, result) {
        if (toolName !== 'get_observations') return null;

        try {
          console.log('Analyzing chart data for tool:', toolName);
          console.log('Raw result:', result);

          const data = typeof result === 'string' ? JSON.parse(result) : result;
          console.log('Parsed data:', data);

          // Must have variable and place_observations
          if (!data.variable || !data.place_observations) {
            console.log('Missing variable or place_observations');
            return null;
          }

          const variableName = data.variable.name || data.variable.dcid;
          const places = data.place_observations;

          if (!places || places.length === 0) {
            console.log('No places found');
            return null;
          }

          // Extract time series data
          const datasets = [];
          let labels = [];

          for (const placeData of places) {
            const placeName = placeData.place?.name || placeData.place?.dcid || 'Unknown';
            const timeSeries = placeData.time_series || [];

            console.log(`Place: ${placeName}, Time series points: ${timeSeries.length}`);

            if (timeSeries.length > 0) {
              // Extract labels (dates) from first place
              if (labels.length === 0) {
                labels = timeSeries.map(point => point[0]);
              }

              // Extract values
              const values = timeSeries.map(point => point[1]);

              datasets.push({
                label: placeName,
                data: values,
                borderColor: getChartColor(datasets.length),
                backgroundColor: getChartColor(datasets.length, 0.2),
                tension: 0.1,
                fill: false
              });
            }
          }

          if (labels.length === 0 || datasets.length === 0) {
            console.log('No valid data points found');
            return null;
          }

          // Determine chart type
          const hasTimeSeries = labels.length > 1;
          const multiplePlaces = datasets.length > 1;
          let chartType = hasTimeSeries ? 'line' : 'bar';

          // Extract source metadata - fields from Data Commons MCP
          const sourceMetadata = data.source_metadata || {};
          const unit = sourceMetadata.unit || '';
          const sourceName = sourceMetadata.import_name || sourceMetadata.source_name || 'Data Commons';
          const sourceUrl = sourceMetadata.provenance_url || sourceMetadata.source_url || '';

          console.log('Chart analysis complete:', {
            chartType,
            variableName,
            labels,
            datasetsCount: datasets.length,
            unit,
            sourceName,
            sourceUrl
          });

          return {
            chartType,
            variableName,
            labels,
            datasets,
            unit,
            sourceName,
            sourceUrl
          };
        } catch (e) {
          console.error('Error analyzing chart data:', e);
          return null;
        }
      }

      // Chart color palette
      function getChartColor(index, alpha = 1) {
        const colors = [
          `rgba(0, 51, 102, ${alpha})`,   // Gov blue
          `rgba(255, 153, 51, ${alpha})`, // Saffron
          `rgba(19, 136, 8, ${alpha})`,   // Green
          `rgba(66, 133, 244, ${alpha})`, // Google blue
          `rgba(234, 67, 53, ${alpha})`,  // Google red
          `rgba(251, 188, 5, ${alpha})`,  // Google yellow
        ];
        return colors[index % colors.length];
      }

      // Format large numbers for display
      function formatNumber(num) {
        if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
        if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
        if (num >= 1e7) return (num / 1e7).toFixed(2) + 'Cr';
        if (num >= 1e5) return (num / 1e5).toFixed(2) + 'L';
        if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
        return num.toLocaleString();
      }

      // Render chart using Chart.js
      async function renderChart(chartData) {
        if (!chartData) return '';

        const chartId = `chart-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const { chartType, variableName, labels, datasets, unit, sourceName, sourceUrl } = chartData;

        // Build source attribution HTML
        let sourceHtml = '';
        if (sourceName || sourceUrl) {
          if (sourceUrl) {
            sourceHtml = `<div class="dc-chart-source">Source: <a href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener">${escapeHtml(sourceName || sourceUrl)}</a></div>`;
          } else {
            sourceHtml = `<div class="dc-chart-source">Source: ${escapeHtml(sourceName)}</div>`;
          }
        }

        // Create chart container HTML
        const containerHtml = `
          <div class="dc-chart-container" id="${chartId}-container">
            <div class="dc-chart-title">${escapeHtml(variableName)}</div>
            <canvas id="${chartId}" style="max-height: 300px;"></canvas>
            <div class="dc-chart-footer">
              ${unit ? `<span class="dc-chart-unit">Unit: ${escapeHtml(unit)}</span>` : ''}
              ${sourceHtml}
            </div>
          </div>
        `;

        return { html: containerHtml, chartId, chartType, labels, datasets, variableName };
      }

      // Inject chart into message after finalization
      async function injectChartIntoMessage(messageEl, chartData) {
        if (!chartData) return;

        try {
          console.log('Injecting chart with data:', chartData);

          await loadChartJs();

          const chartConfig = await renderChart(chartData);
          if (!chartConfig) return;

          const contentEl = messageEl.querySelector('.message-content');
          if (!contentEl) return;

          // Insert chart container
          contentEl.insertAdjacentHTML('beforeend', chartConfig.html);
          chatMessages.scrollTop = chatMessages.scrollHeight;

          // Wait for DOM to update
          await new Promise(r => setTimeout(r, 100));

          // Create the chart
          const canvas = document.getElementById(chartConfig.chartId);
          if (!canvas) {
            console.error('Canvas not found:', chartConfig.chartId);
            return;
          }

          const ctx = canvas.getContext('2d');

          new Chart(ctx, {
            type: chartConfig.chartType,
            data: {
              labels: chartConfig.labels,
              datasets: chartConfig.datasets
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              plugins: {
                legend: {
                  display: chartConfig.datasets.length > 1,
                  position: 'bottom'
                },
                title: {
                  display: false
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const value = context.parsed.y;
                      return `${context.dataset.label}: ${formatNumber(value)}`;
                    }
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: false,
                  ticks: {
                    callback: function(value) {
                      return formatNumber(value);
                    }
                  }
                }
              }
            }
          });

          console.log('Chart rendered successfully');
          chatMessages.scrollTop = chatMessages.scrollHeight;

        } catch (err) {
          console.error('Failed to inject chart:', err);
          const contentEl = messageEl.querySelector('.message-content');
          if (contentEl) {
            contentEl.insertAdjacentHTML('beforeend',
              `<div class="dc-chart-error">Unable to load visualization: ${err.message}</div>`
            );
          }
        }
      }

      // DOM Elements
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const welcomeMessage = document.getElementById('welcome-message');
      const apiKeyInput = document.getElementById('api-key-input');
      const mcpUrlInput = document.getElementById('mcp-url-input');
      const mcpEnabledCheckbox = document.getElementById('mcp-enabled');
      const kbStoreInput = document.getElementById('kb-store-input');
      const kbEnabledCheckbox = document.getElementById('kb-enabled');
      const saveConfigBtn = document.getElementById('save-config');
      const configStatus = document.getElementById('config-status');

      // New sidebar elements
      const leftSidebar = document.getElementById('left-sidebar');
      const rightSidebar = document.getElementById('right-sidebar');
      const toolCallsContainer = document.getElementById('tool-calls-container');
      const settingsFab = document.getElementById('settings-fab');
      const closeSettings = document.getElementById('close-settings');
      const mcpStatus = document.getElementById('mcp-status');
      const kbStatus = document.getElementById('kb-status');

      // Models - use different models for different purposes
      const MCP_MODEL = 'gemini-2.0-flash';  // For MCP function calling (proven to work)
      const KB_MODEL = 'gemini-2.5-flash';   // For file search (requires 2.5)

      // System instructions
      const mcpSystemInstruction = `## Role
You are a High-Precision Data Research Assistant. Your sole source of truth for quantitative data is the Data Commons MCP toolset.

## Operational Protocol
1. **Identify Variables:** For any quantitative query, first call search_indicators to find the right variable.
2. **Retrieve Data:** Extract the 'variable_dcid' from the search results. Use this with the correct 'place_dcid' in 'get_observations'.
3. **Handle Time Series:** If a user asks for "trends" or "history," set the 'date' parameter to "all" or a specific range if available; otherwise, default to "latest."

## CRITICAL - Tool Parameter Formats
- **search_indicators:** Use HUMAN-READABLE place names, NOT DCIDs!
  - CORRECT: search_indicators(query="GDP", places=["India"])
  - CORRECT: search_indicators(query="population", places=["United States"])
  - CORRECT: search_indicators(query="unemployment", places=["California, USA"])
  - WRONG: search_indicators(query="GDP", places=["country/IND"]) <- DO NOT USE DCIDs HERE!

- **get_observations:** Use DCIDs for places
  - CORRECT: get_observations(variable_dcid="...", place_dcid="country/IND", date="latest")
  - CORRECT: get_observations(variable_dcid="...", place_dcid="country/USA", date="latest")
  - CORRECT: get_observations(variable_dcid="...", place_dcid="geoId/06", date="latest")

## Common Place Mappings
- India -> country/IND
- United States -> country/USA
- California -> geoId/06
- Texas -> geoId/48

## Strict Constraints
- **Anti-Hallucination:** NEVER generate numerical data, percentages, or dates from internal knowledge. If the tool returns no results, state: "The requested data is not available in Data Commons."
- **Data Presentation:** Use Markdown tables for multi-year or multi-region data. Always include 'Source: Data Commons' and the observation date. If units are provided, display them.

## Goal
Provide audit-ready statistical facts with 100% traceability to the Data Commons database.`;

      const kbSystemInstruction = `## Role
You are a Corporate Knowledge Auditor. Your purpose is to provide factual answers based strictly on the provided internal policy documentation.

## Operational Protocol
1. **Search & Locate:** Scan the Knowledge Base for the specific policy, clause, or procedure requested.
2. **Contextual Response:** Synthesize the answer clearly. If the policy specifies conditions (e.g., "Only applicable to full-time employees"), include those constraints.
3. **Attribution:** Every response MUST conclude with a citation identifying the source document. Format: "Source: [Document_Name.pdf]"

## Strict Constraints
- **Knowledge Boundary:** If the information is not explicitly stated in the Knowledge Base, respond with: "No relevant information found in the knowledge base." Do NOT supplement with general internet knowledge.
- **Tone:** Maintain a professional, neutral, and objective tone. Do not interpret policy; report it as written.
- **Conflicting Info:** If two documents provide conflicting information, highlight both and cite their respective filenames so the user can see the discrepancy.

## Goal
To serve as a reliable "Single Source of Truth" for organizational policies and internal documentation.`;

      // Initialize
      function init() {
        // Load saved config
        if (geminiApiKey) apiKeyInput.value = geminiApiKey;
        if (mcpProxyUrl) mcpUrlInput.value = mcpProxyUrl;
        mcpEnabledCheckbox.checked = mcpEnabled;
        if (kbStoreId) kbStoreInput.value = kbStoreId;
        kbEnabledCheckbox.checked = kbEnabled;

        // Event listeners
        saveConfigBtn.addEventListener('click', saveConfig);
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', handleKeyDown);
        chatInput.addEventListener('input', autoResize);

        // Settings sidebar toggle
        if (closeSettings) {
          closeSettings.addEventListener('click', () => {
            rightSidebar.classList.add('hidden');
            settingsFab.classList.add('visible');
          });
        }

        if (settingsFab) {
          settingsFab.addEventListener('click', () => {
            rightSidebar.classList.remove('hidden');
            settingsFab.classList.remove('visible');
          });
        }

        // Update status badges
        updateStatusBadges();

        // Suggestion buttons
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.addEventListener('click', () => {
            if (!btn.disabled) {
              chatInput.value = btn.dataset.text;
              sendMessage();
            }
          });
        });

        // Auto-connect if config exists
        if (geminiApiKey) {
          saveConfig();
        }
      }

      // Save configuration and connect
      async function saveConfig() {
        const key = apiKeyInput.value.trim();
        const url = mcpUrlInput.value.trim();
        const enabled = mcpEnabledCheckbox.checked;
        const kbStore = kbStoreInput.value.trim();
        const kbOn = kbEnabledCheckbox.checked;

        if (!key) {
          configStatus.textContent = 'Please enter a Gemini API key';
          configStatus.style.color = 'var(--danger)';
          return;
        }

        geminiApiKey = key;
        mcpProxyUrl = url;
        mcpEnabled = enabled;
        kbStoreId = kbStore;
        kbEnabled = kbOn;

        localStorage.setItem('gemini_api_key', key);
        localStorage.setItem('mcp_proxy_url', url);
        localStorage.setItem('mcp_enabled', enabled.toString());
        localStorage.setItem('kb_store_id', kbStore);
        localStorage.setItem('kb_enabled', kbOn.toString());

        configStatus.textContent = 'Connecting...';
        configStatus.style.color = 'var(--text-muted)';

        // Check MCP connection if enabled
        if (mcpEnabled && url) {
          const connected = await checkMcpConnection();
          mcpConnected = connected;
        } else {
          mcpConnected = false;
        }

        enableChat();
        updateStatusBadges();

        configStatus.innerHTML = 'Connected! <span style="color: var(--success);">Ready to chat.</span>';
      }

      // Check MCP proxy connection and fetch tools
      async function checkMcpConnection() {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/tools`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });

          if (!response.ok) return false;

          const data = await response.json();
          if (data.success && data.tools) {
            mcpTools = data.tools;
            console.log('MCP Tools loaded:', mcpTools.map(t => t.name));
            return true;
          }
          return false;
        } catch (err) {
          console.error('MCP connection error:', err);
          return false;
        }
      }

      // Execute MCP tool call
      async function executeMcpToolCall(name, args) {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/call`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, arguments: args })
          });

          const data = await response.json();

          if (data.success && data.result) {
            // Extract text content from MCP result
            const content = data.result.content;
            if (Array.isArray(content)) {
              return content.map(c => c.text || JSON.stringify(c)).join('\n');
            }
            return JSON.stringify(data.result);
          }

          return JSON.stringify({ error: data.error || 'Unknown error' });
        } catch (err) {
          console.error('MCP tool call error:', err);
          return JSON.stringify({ error: err.message });
        }
      }

      function enableChat() {
        chatInput.disabled = false;
        chatInput.placeholder = mcpConnected
          ? 'Ask about MSME policies, statistics, or government schemes...'
          : 'Ask questions about policies or upload documents...';
        sendBtn.disabled = false;
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.disabled = false;
        });
      }

      // Auto-resize textarea
      function autoResize() {
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';
      }

      function handleKeyDown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      }

      // Update status badges in settings sidebar
      function updateStatusBadges() {
        if (mcpStatus) {
          mcpStatus.textContent = mcpConnected ? 'Connected' : 'Disconnected';
          mcpStatus.className = mcpConnected ? 'status-badge active' : 'status-badge';
        }
        if (kbStatus) {
          kbStatus.textContent = kbEnabled ? 'Active' : 'Inactive';
          kbStatus.className = kbEnabled ? 'status-badge active' : 'status-badge';
        }
      }

      // Clear tool calls from left sidebar
      function clearToolCalls() {
        if (toolCallsContainer) {
          toolCallsContainer.innerHTML = '';
        }
      }

      // Show tool call in LEFT SIDEBAR (not chat)
      function showToolCall(name, args) {
        // Clear empty message if present
        const emptyMsg = toolCallsContainer.querySelector('.tool-calls-empty');
        if (emptyMsg) emptyMsg.remove();

        const toolEl = document.createElement('div');
        toolEl.className = 'tool-call-item loading';
        toolEl.innerHTML = `
          <div class="tool-call-name">
            <span>${escapeHtml(name)}</span>
            <span class="badge">Running</span>
          </div>
          <div class="tool-call-args">${escapeHtml(JSON.stringify(args, null, 2))}</div>
          <div class="tool-call-result"></div>
        `;
        toolCallsContainer.appendChild(toolEl);
        toolCallsContainer.scrollTop = toolCallsContainer.scrollHeight;
        return toolEl;
      }

      function updateToolCallResult(toolEl, result, isError = false, toolName = '') {
        toolEl.classList.remove('loading');
        toolEl.classList.add(isError ? 'error' : 'success');

        // Update badge
        const badge = toolEl.querySelector('.badge');
        if (badge) {
          badge.textContent = isError ? 'Error' : 'Done';
          badge.style.background = isError ? 'var(--danger)' : 'var(--green)';
        }

        const resultEl = toolEl.querySelector('.tool-call-result');
        resultEl.className = `tool-call-result ${isError ? 'error' : 'success'}`;

        // Truncate long results
        let displayResult = result;
        if (result.length > 300) {
          displayResult = result.substring(0, 300) + '... (truncated)';
        }
        resultEl.textContent = displayResult;

        // Analyze for chart data and extract source if this is a get_observations call
        if (!isError && toolName === 'get_observations') {
          try {
            const chartData = analyzeChartData(toolName, result);
            if (chartData) {
              lastChartAnalysis = chartData;
              console.log('Chart data extracted:', chartData);

              // Also store source info for text responses
              if (chartData.sourceName || chartData.sourceUrl) {
                lastDataSource = {
                  name: chartData.sourceName,
                  url: chartData.sourceUrl
                };
                console.log('Data source stored:', lastDataSource);
              }
            }
          } catch (e) {
            console.error('Chart analysis error:', e);
          }
        }

        // Also try to extract source from search_indicators results
        if (!isError && toolName === 'search_indicators') {
          try {
            const data = typeof result === 'string' ? JSON.parse(result) : result;
            // search_indicators doesn't return source directly, but we note it's from Data Commons
            if (data.variables || data.topics) {
              lastDataSource = {
                name: 'Data Commons',
                url: 'https://datacommons.org'
              };
            }
          } catch (e) {
            // Ignore parse errors
          }
        }
      }

      // ============================================================
      // PHASE 1: MCP Tools Query (using gemini-2.0-flash)
      // ============================================================
      async function queryWithMcpTools(userMessage) {
        if (!mcpConnected || mcpTools.length === 0) {
          console.log('MCP not connected or no tools available');
          return { success: false, response: null, error: 'MCP not connected' };
        }

        console.log('=== Starting MCP Query ===');
        console.log(`MCP Tools available: ${mcpTools.map(t => t.name).join(', ')}`);

        try {
          // Build contents with conversation history
          const contents = [];
          // Add conversation history (limit to last 10 turns to avoid token limits)
          const historyLimit = Math.max(0, conversationHistory.length - 20);
          for (let i = historyLimit; i < conversationHistory.length; i++) {
            contents.push(conversationHistory[i]);
          }
          // Add current user message
          contents.push({ role: 'user', parts: [{ text: userMessage }] });

          // Function calling loop
          let maxIterations = 5;
          let iteration = 0;

          while (iteration < maxIterations) {
            iteration++;

            // Build payload
            const payload = {
              contents: contents,
              systemInstruction: { parts: [{ text: mcpSystemInstruction }] },
              generationConfig: {
                temperature: 0.7,
                topP: 0.95,
                topK: 40
              }
            };

            // Add tools if MCP is connected
            const dataKeywords = /population|gdp|unemployment|rate|statistics|data|how many|what is the|number of|percent|average|median|income|health|economy|demographics|emissions|climate|crime|education|exports|imports|export|import|trade|dairy|agriculture|production|manufacturing|industry|growth|trend|value|amount|total/i;
            const isDataQuery = dataKeywords.test(userMessage);

            if (iteration >= 3) {
              // Don't include tools - force pure text response
              console.log(`MCP Iteration ${iteration}: Forcing text response (no tools)`);
            } else {
              // Simplify tool descriptions for Gemini - use longer limit for better understanding
              const simplifiedTools = mcpTools.map(t => ({
                name: t.name,
                description: t.description.length > 2000
                  ? t.description.substring(0, 2000) + '...'
                  : t.description,
                parameters: t.parameters
              }));
              payload.tools = [{ functionDeclarations: simplifiedTools }];

              const mode = (iteration === 1 && isDataQuery) ? 'ANY' : 'AUTO';
              console.log(`MCP Iteration ${iteration}: Using mode ${mode}`);
              payload.toolConfig = {
                functionCallingConfig: { mode: mode }
              };
            }

            // Call Gemini with MCP_MODEL (2.0-flash)
            console.log('MCP Request payload:', JSON.stringify(payload, null, 2));

            const response = await fetch(
              `${GEMINI_API_BASE}/${MCP_MODEL}:generateContent?key=${geminiApiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              }
            );

            const data = await response.json();
            console.log('MCP Response:', JSON.stringify(data, null, 2));

            if (data.error) {
              throw new Error(data.error.message || 'MCP API request failed');
            }

            const candidates = data.candidates || [];
            if (candidates.length === 0) {
              throw new Error('No response from MCP query');
            }

            const responseParts = candidates[0].content?.parts || [];
            const functionCalls = responseParts.filter(p => p.functionCall);

            if (functionCalls.length > 0 && mcpConnected) {
              // Add model response to conversation
              contents.push({ role: 'model', parts: responseParts });

              // Execute tool calls
              const functionResponses = [];
              for (const part of functionCalls) {
                const fc = part.functionCall;
                console.log(`Executing MCP tool: ${fc.name}`, fc.args);

                // Show tool call in UI
                const toolEl = showToolCall(fc.name, fc.args);

                try {
                  const result = await executeMcpToolCall(fc.name, fc.args);
                  updateToolCallResult(toolEl, result, false, fc.name);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { result: result }
                    }
                  });
                } catch (err) {
                  updateToolCallResult(toolEl, err.message, true, fc.name);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { error: err.message }
                    }
                  });
                }
              }

              // Add function responses
              contents.push({ role: 'user', parts: functionResponses });

            } else {
              // Got text response
              const textParts = responseParts.filter(p => p.text);
              if (textParts.length > 0) {
                const response = textParts.map(p => p.text).join('\n');
                console.log('MCP Query successful');
                return { success: true, response: response, error: null };
              }
              break;
            }
          }

          return { success: false, response: null, error: 'MCP query did not produce response' };

        } catch (err) {
          console.error('MCP Query error:', err);
          return { success: false, response: null, error: err.message };
        }
      }

      // ============================================================
      // PHASE 2: Knowledge Base Query (using gemini-2.5-flash)
      // ============================================================
      async function queryWithKnowledgeBase(userMessage) {
        if (!kbEnabled || !kbStoreId) {
          console.log('Knowledge base not enabled or no store ID');
          return { success: false, response: null, sources: [], error: 'KB not configured' };
        }

        console.log('=== Starting Knowledge Base Query ===');
        console.log(`KB Store: ${kbStoreId}`);

        try {
          // Build contents with conversation history
          const contents = [];
          // Add conversation history (limit to last 10 turns to avoid token limits)
          const historyLimit = Math.max(0, conversationHistory.length - 20);
          for (let i = historyLimit; i < conversationHistory.length; i++) {
            contents.push(conversationHistory[i]);
          }
          // Add current user message
          contents.push({ role: 'user', parts: [{ text: userMessage }] });

          const payload = {
            contents: contents,
            systemInstruction: { parts: [{ text: kbSystemInstruction }] },
            tools: [{
              fileSearch: {
                fileSearchStoreNames: [kbStoreId]
              }
            }],
            generationConfig: {
              temperature: 0.3,
              topP: 0.95,
              topK: 40
            }
          };

          console.log('KB Request payload:', JSON.stringify(payload, null, 2));

          const response = await fetch(
            `${GEMINI_API_BASE}/${KB_MODEL}:generateContent?key=${geminiApiKey}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }
          );

          const data = await response.json();
          console.log('KB Response:', JSON.stringify(data, null, 2));

          if (data.error) {
            throw new Error(data.error.message || 'KB API request failed');
          }

          const candidates = data.candidates || [];
          if (candidates.length === 0) {
            return { success: false, response: null, sources: [], error: 'No KB response' };
          }

          const responseParts = candidates[0].content?.parts || [];
          const textParts = responseParts.filter(p => p.text);
          const responseText = textParts.map(p => p.text).join('\n');

          // Extract sources from grounding metadata
          const sources = [];
          const groundingMetadata = candidates[0].groundingMetadata;
          if (groundingMetadata && groundingMetadata.groundingChunks) {
            groundingMetadata.groundingChunks
              .filter(chunk => chunk.retrievedContext)
              .forEach(chunk => {
                const source = chunk.retrievedContext.title || chunk.retrievedContext.uri;
                if (source && !sources.includes(source)) {
                  sources.push(source);
                }
              });
          }

          console.log('KB Query successful, sources:', sources);
          return { success: true, response: responseText, sources: sources, error: null };

        } catch (err) {
          console.error('KB Query error:', err);
          return { success: false, response: null, sources: [], error: err.message };
        }
      }

      // ============================================================
      // MAIN: Send message - calls BOTH MCP and KB, combines results
      // ============================================================
      async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message || isProcessing || !geminiApiKey) return;

        // Hide welcome message
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }

        // Clear previous tool calls from left sidebar
        clearToolCalls();

        // Reset data source tracking for new query
        lastDataSource = null;

        // Show user message
        addMessage('user', message);

        // Clear input
        chatInput.value = '';
        autoResize();

        // Start processing
        isProcessing = true;
        sendBtn.disabled = true;
        chatInput.disabled = true;
        const typingEl = showTypingIndicator();

        const userMessage = message;

        try {
          console.log('=== Processing Query ===');
          console.log(`User message: ${userMessage}`);
          console.log(`MCP connected: ${mcpConnected}, Tools: ${mcpTools.length}`);
          console.log(`KB enabled: ${kbEnabled}, Store: ${kbStoreId}`);

          // Run BOTH queries in parallel
          const [mcpResult, kbResult] = await Promise.all([
            queryWithMcpTools(userMessage),
            queryWithKnowledgeBase(userMessage)
          ]);

          console.log('MCP Result:', mcpResult);
          console.log('KB Result:', kbResult);

          // Remove typing indicator and create streaming message
          typingEl.remove();
          const streamingMessage = createStreamingMessage();

          // Combine results naturally
          let finalResponse = '';
          let mcpContent = '';
          let kbContent = '';
          let sources = [];

          // Get MCP response content
          if (mcpResult.success && mcpResult.response) {
            mcpContent = mcpResult.response;
          }

          // Get KB response content (if relevant)
          if (kbResult.success && kbResult.response) {
            const noInfoPatterns = /no relevant information|not found in|cannot find|no information available/i;
            if (!noInfoPatterns.test(kbResult.response)) {
              kbContent = kbResult.response;
              if (kbResult.sources && kbResult.sources.length > 0) {
                sources = kbResult.sources;
              }
            }
          }

          // If we have both, use Gemini to synthesize a natural response with streaming
          if (mcpContent && kbContent) {
            try {
              // Build synthesis contents with conversation history for context
              const synthesisContents = [];
              // Add conversation history summary for context
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-10).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 200)}...`
                ).join('\n');
                synthesisContents.push({
                  role: 'user',
                  parts: [{
                    text: `Previous conversation context:\n${recentHistory}\n\n---\n\nNow, combine these two pieces of information into a single, coherent, natural response to the user's latest question. Do not use labels like "From Data Commons" or "From Policy Documents". Just provide a unified helpful answer.

User's latest question: ${userMessage}

Statistical/Data information:
${mcpContent}

Policy/Document information:
${kbContent}

Provide a natural, combined response that integrates both pieces of information smoothly:`
                  }]
                });
              } else {
                synthesisContents.push({
                  role: 'user',
                  parts: [{
                    text: `You are an assistant helping with MSME and policy queries. Combine these two pieces of information into a single, coherent, natural response. Do not use labels like "From Data Commons" or "From Policy Documents". Just provide a unified helpful answer.

User's question: ${userMessage}

Statistical/Data information:
${mcpContent}

Policy/Document information:
${kbContent}

Provide a natural, combined response that integrates both pieces of information smoothly:`
                  }]
                });
              }

              const synthesisPayload = {
                contents: synthesisContents,
                generationConfig: {
                  temperature: 0.3,
                  topP: 0.95
                }
              };

              // Use streaming for synthesis
              finalResponse = await streamGeminiResponse(synthesisPayload, 'gemini-2.0-flash', streamingMessage);

            } catch (err) {
              console.error('Synthesis streaming error:', err);
              // Fallback: just combine them without streaming
              finalResponse = mcpContent + '\n\n' + kbContent;
              streamingMessage.setText(finalResponse);
            }
          } else if (mcpContent) {
            // Stream a refined response for MCP-only content with conversation context
            try {
              let refinePrompt = '';
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-6).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 150)}...`
                ).join('\n');
                refinePrompt = `Previous conversation:\n${recentHistory}\n\n---\n\nUser's latest question: ${userMessage}\n\nData retrieved:\n${mcpContent}\n\nProvide a natural, helpful response based on the data and conversation context:`;
              } else {
                refinePrompt = `Rephrase and present this information naturally and helpfully to the user. Keep all the data accurate but make it conversational:\n\n${mcpContent}`;
              }
              const refinePayload = {
                contents: [{
                  role: 'user',
                  parts: [{ text: refinePrompt }]
                }],
                generationConfig: { temperature: 0.3, topP: 0.95 }
              };
              finalResponse = await streamGeminiResponse(refinePayload, 'gemini-2.0-flash', streamingMessage);
            } catch (err) {
              // Fallback to non-streamed
              finalResponse = mcpContent;
              streamingMessage.setText(finalResponse);
            }
          } else if (kbContent) {
            // Stream the KB content directly (already formatted)
            // Simulate streaming by adding text in chunks
            const words = kbContent.split(' ');
            finalResponse = '';
            for (let i = 0; i < words.length; i++) {
              finalResponse += (i > 0 ? ' ' : '') + words[i];
              streamingMessage.setText(finalResponse);
              // Small delay to simulate streaming effect
              if (i % 5 === 0) {
                await new Promise(r => setTimeout(r, 20));
              }
            }
          } else {
            // Neither worked
            if (mcpResult.error && kbResult.error) {
              finalResponse = 'I was unable to retrieve information for your query. Please try rephrasing your question.';
            } else {
              finalResponse = 'No relevant information found for your query.';
            }
            streamingMessage.setText(finalResponse);
          }

          // Add sources at the end if available
          const allSources = [];

          // Add MCP/Data Commons source
          if (lastDataSource) {
            if (lastDataSource.url) {
              allSources.push(`[${lastDataSource.name || 'Data Commons'}](${lastDataSource.url})`);
            } else if (lastDataSource.name) {
              allSources.push(lastDataSource.name);
            }
          }

          // Add KB sources
          if (sources.length > 0) {
            allSources.push(...sources);
          }

          if (allSources.length > 0) {
            finalResponse += '\n\n**Data Sources:** ' + allSources.join(' | ');
            streamingMessage.setText(finalResponse);
          }

          // Finalize the streaming message (remove cursor)
          streamingMessage.finalize();

          // Inject chart visualization if we have chart data
          if (lastChartAnalysis) {
            console.log('Injecting chart with analysis:', lastChartAnalysis);
            await injectChartIntoMessage(streamingMessage.element, lastChartAnalysis);
            lastChartAnalysis = null;  // Reset for next query
          }

          // Reset data source
          lastDataSource = null;

          // Update conversation history
          conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
          conversationHistory.push({ role: 'model', parts: [{ text: finalResponse }] });

        } catch (err) {
          // Safely remove typing indicator if it still exists
          if (typingEl && typingEl.parentNode) {
            typingEl.remove();
          }
          console.error('Chat error:', err);

          if (err.message.includes('API key')) {
            showError('Invalid API key. Please check your Gemini API key.');
          } else {
            showError(`Error: ${err.message}`);
          }
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          chatInput.disabled = false;
          chatInput.focus();
        }
      }

      // UI helpers
      function addMessage(role, content) {
        const messageEl = document.createElement('div');
        messageEl.className = `message ${role}`;

        const avatar = role === 'user' ? 'You' : 'VS';
        const formattedContent = formatMessage(content);

        messageEl.innerHTML = `
          <div class="message-avatar">${avatar}</div>
          <div class="message-content">${formattedContent}</div>
        `;

        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Create a streaming message bubble that can be updated
      function createStreamingMessage() {
        const messageEl = document.createElement('div');
        messageEl.className = 'message assistant';
        messageEl.innerHTML = `
          <div class="message-avatar">VS</div>
          <div class="message-content"><span class="streaming-cursor">▊</span></div>
        `;
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        const contentEl = messageEl.querySelector('.message-content');
        let currentText = '';

        return {
          element: messageEl,
          // Update with new text chunk
          appendText: (text) => {
            currentText += text;
            contentEl.innerHTML = formatMessage(currentText) + '<span class="streaming-cursor">▊</span>';
            chatMessages.scrollTop = chatMessages.scrollHeight;
          },
          // Finalize the message (remove cursor)
          finalize: () => {
            contentEl.innerHTML = formatMessage(currentText);
            chatMessages.scrollTop = chatMessages.scrollHeight;
          },
          // Get current text
          getText: () => currentText,
          // Set full text
          setText: (text) => {
            currentText = text;
            contentEl.innerHTML = formatMessage(currentText) + '<span class="streaming-cursor">▊</span>';
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
        };
      }

      // Stream content from Gemini API
      async function streamGeminiResponse(payload, model, streamingMessage) {
        const url = `${GEMINI_API_BASE}/${model}:streamGenerateContent?key=${geminiApiKey}&alt=sse`;

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || 'Streaming request failed');
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let fullText = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            // Parse SSE data - each chunk may have multiple "data:" lines
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const jsonStr = line.slice(6);
                if (jsonStr.trim() === '[DONE]') continue;

                try {
                  const data = JSON.parse(jsonStr);
                  const candidates = data.candidates || [];
                  if (candidates.length > 0) {
                    const parts = candidates[0].content?.parts || [];
                    for (const part of parts) {
                      if (part.text) {
                        fullText += part.text;
                        streamingMessage.setText(fullText);
                      }
                    }
                  }
                } catch (e) {
                  // Ignore parse errors for partial JSON
                }
              }
            }
          }

          return fullText;
        } catch (err) {
          console.error('Streaming error:', err);
          throw err;
        }
      }

      function formatMessage(content) {
        // First extract and preserve markdown links before escaping
        const linkPlaceholders = [];
        let processed = content.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (match, text, url) => {
          const placeholder = `__LINK_${linkPlaceholders.length}__`;
          linkPlaceholders.push({ text, url });
          return placeholder;
        });

        // Now escape HTML
        let formatted = escapeHtml(processed);

        // Restore links as proper HTML anchors
        linkPlaceholders.forEach((link, i) => {
          formatted = formatted.replace(`__LINK_${i}__`,
            `<a href="${escapeHtml(link.url)}" target="_blank" rel="noopener" style="color: var(--gov-blue);">${escapeHtml(link.text)}</a>`);
        });

        // Apply other markdown formatting
        formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
        formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        formatted = formatted.replace(/\n/g, '<br>');
        return formatted;
      }

      function showTypingIndicator() {
        const typingEl = document.createElement('div');
        typingEl.className = 'message assistant';
        typingEl.innerHTML = `
          <div class="message-avatar">VS</div>
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        `;
        chatMessages.appendChild(typingEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return typingEl;
      }

      function showError(message) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = message;
        chatMessages.appendChild(errorEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        setTimeout(() => errorEl.remove(), 10000);
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Initialize
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
{% endblock %}
