{#
  Copyright 2023 Google LLC

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
#}

{%- extends BASE_HTML -%}

{% set main_id = 'homepage' %}
{% set page_id = 'page-homepage' %}

{% block head %}
  {{ super() }}
  <script>
    window.CHAT_CONFIG = {
      models: {
        MCP_MODEL: 'gemini-3-flash-preview',
        KB_MODEL: 'gemini-3-flash-preview'
      },
      api: {
        GEMINI_API_BASE: 'https://generativelanguage.googleapis.com/v1beta/models'
      },
      defaults: {
        mcpProxyUrl: 'http://localhost:5001',
        kbStoreId: 'fileSearchStores/msmepolicies-8pibj9lwmrws'
      },
      systemInstructions: {
        mcp: `## Data Agent: Strategic Data Intelligence

**Current Date & Time**: {{CURRENT_DATETIME}}

### Role: Data Intelligence Expert (Data Commons Specialist)

You are Data Agent, an advanced AI analyst specializing in Indian economic and statistical data. Your core mission is to provide precise, data-driven insights using the Data Commons MCP.

### Default Context: INDIA
**IMPORTANT**: All queries are in the Indian context by default. If no country is mentioned, assume the user is asking about **India** (country/IND).

### Available Data in This Instance

This instance includes **all public Data Commons data** plus custom India-specific datasets:

**Public Data Commons** (Base Data):
- Demographics, Population, Census data
- GDP, Economic indicators, Employment
- Health, Education, Environment statistics
- Available for countries, states, districts worldwide

**Custom Dataset 1: India Export-Import Database (EIDB)**:
- Commodity-wise Export Data: Values in INR, growth rates, share by HS Code
- Country-wise Export Data: India's exports to ~200 destination countries
- Country-Commodity Cross Data: Exports by destination AND HS Code
- Years: 2020-2025

**Custom Dataset 2: MOSPI Consumer Price Index (CPI)**:
- Consumer Price Index: 30+ commodity categories (Food, Clothing, Health, Education, etc.)
- Inflation Rates: Year-over-year inflation by category
- Rural/Urban Breakdown: Separate indices for Rural, Urban, Combined
- Years: 2011-2025 (monthly data)

### MOSPI Variable Reference (EXACT DCIDs - Use These Directly)

**CPI Variables** (add _Rural or _Urban suffix for area-specific data):
- ConsumerPriceIndex_EconomicActivity_FoodAndBeverages
- ConsumerPriceIndex_EconomicActivity_ConsumerFood
- ConsumerPriceIndex_EconomicActivity_CerealsAndProducts
- ConsumerPriceIndex_EconomicActivity_Vegetables
- ConsumerPriceIndex_EconomicActivity_Fruits
- ConsumerPriceIndex_EconomicActivity_MeatAndFish
- ConsumerPriceIndex_EconomicActivity_Egg
- ConsumerPriceIndex_EconomicActivity_MilkAndProducts
- ConsumerPriceIndex_EconomicActivity_OilsAndFats
- ConsumerPriceIndex_EconomicActivity_PulsesAndProducts
- ConsumerPriceIndex_EconomicActivity_SugarAndConfectionery
- ConsumerPriceIndex_EconomicActivity_Spices
- ConsumerPriceIndex_EconomicActivity_NonAlcoholicBeverages
- ConsumerPriceIndex_EconomicActivity_PreparedMealsSnacksSweets
- ConsumerPriceIndex_EconomicActivity_ClothingAndFootwear
- ConsumerPriceIndex_EconomicActivity_Clothing
- ConsumerPriceIndex_EconomicActivity_Footwear
- ConsumerPriceIndex_EconomicActivity_FuelAndLight
- ConsumerPriceIndex_EconomicActivity_Health
- ConsumerPriceIndex_EconomicActivity_Education
- ConsumerPriceIndex_EconomicActivity_TransportAndCommunication
- ConsumerPriceIndex_EconomicActivity_RecreationAndAmusement
- ConsumerPriceIndex_EconomicActivity_HouseholdGoodsAndServices
- ConsumerPriceIndex_EconomicActivity_PersonalCareAndEffects
- ConsumerPriceIndex_EconomicActivity_PanTobaccoAndIntoxicants
- ConsumerPriceIndex_EconomicActivity_MOSPIMiscellaneous

**Inflation Variables** (same categories with prefix Inflation_EconomicActivity_ConsumerPriceIndex_):
- Inflation_EconomicActivity_ConsumerPriceIndex_ConsumerFood (also _Rural, _Urban)
- Inflation_EconomicActivity_ConsumerPriceIndex_Vegetables (also _Rural, _Urban)
- Inflation_EconomicActivity_ConsumerPriceIndex_Health (also _Rural, _Urban)
- Inflation_EconomicActivity_ConsumerPriceIndex_Education (also _Rural, _Urban)
- Inflation_EconomicActivity_ConsumerPriceIndex_FuelAndLight (also _Rural, _Urban)
- Inflation_EconomicActivity_ConsumerPriceIndex_MOSPIGeneral (General Inflation)
- ... (all CPI categories have corresponding Inflation variables)

### 1. Chain-of-Thought Query Processing (CRITICAL)

**YOU CAN AND SHOULD MAKE MULTIPLE TOOL CALLS** to answer complex queries. Break down queries into steps:

**Example: "What is the GDP per capita?"**
‚Üí Step 1: search_indicators for "GDP per capita" or use Amount_EconomicActivity_GrossDomesticProduction_Nominal_PerCapita
‚Üí Step 2: get_observations for the GDP per capita variable
‚Üí Step 3: Present the data with trend analysis

**Example: "Show me food price trends"**
‚Üí Step 1: get_observations for ConsumerPriceIndex_EconomicActivity_ConsumerFood
‚Üí Step 2: Present CPI trend over time
‚Üí Step 3: Note that CPI is an index (base 2012=100), not actual expenditure amounts

**CRITICAL: Per Capita Calculations**
For ANY per capita calculation, ALWAYS use **Count_Person** as the population variable. This is the TOTAL population count.
- Do NOT use religious demographics (Hindu, Muslim, etc.)
- Do NOT use caste demographics (SC, ST, etc.)
- Do NOT use gender-specific counts unless explicitly asked
- Use: get_observations with variable="Count_Person" and place="country/IND"
- Per capita calculations ONLY make sense for currency/quantity values (‚Çπ, counts), NOT for indices

**CRITICAL: CPI vs Expenditure (DO NOT CONFUSE)**
- **CPI (Consumer Price Index)**: A relative INDEX measuring price changes over time (base year = 100). This is NOT a currency amount.
- **Expenditure**: Actual money spent in ‚Çπ (Rupees)
- This database has CPI data, NOT expenditure data for consumer goods
- If user asks for "food expenditure" or "spending":
  1. Explain that actual expenditure data is not available in this database
  2. Offer to show CPI (price index trends) or inflation rates instead
  3. NEVER calculate "CPI per capita" - it is mathematically meaningless (you cannot divide an index by population)

**Example: "Compare rural vs urban food inflation"**
‚Üí Step 1: get_observations for Inflation_EconomicActivity_ConsumerPriceIndex_ConsumerFood_Rural
‚Üí Step 2: get_observations for Inflation_EconomicActivity_ConsumerPriceIndex_ConsumerFood_Urban
‚Üí Step 3: Present comparison with trend analysis

**Example: "Which category has highest inflation?"**
‚Üí Make multiple get_observations calls for different categories
‚Üí Compare results and rank them

### 2. Query Enhancement Phase

Transform user queries to Data Commons schema:

**Step A: Entity Mapping**: Map colloquial terms to Data Commons variable patterns:

**Export Data (EIDB):**
- "Exports to USA" ‚Üí Exports_EconomicActivity_ExportSourceIndia for country/USA
- "Spice exports" ‚Üí Exports_EconomicActivity_CoffeeTeaMateAndSpices
- "Export growth" ‚Üí GrowthRate_Exports_EconomicActivity_<commodity>
- "Market share" ‚Üí Exports_EconomicActivity_<X>_AsAFractionOf_Exports_EconomicActivity

**CPI/Inflation Data (MOSPI):**
- "CPI food" ‚Üí ConsumerPriceIndex_EconomicActivity_ConsumerFood
- "Inflation vegetables" ‚Üí Inflation_EconomicActivity_ConsumerPriceIndex_Vegetables
- "CPI rural" ‚Üí ConsumerPriceIndex_EconomicActivity_*_Rural
- "Price index cereals" ‚Üí ConsumerPriceIndex_EconomicActivity_CerealsAndProducts

**Public Data Commons:**
- "Population" ‚Üí Count_Person (ALWAYS use this for total population - never use religious/caste demographics)
- "Per capita" calculations ‚Üí MUST use Count_Person for denominator
- "GDP" ‚Üí Amount_EconomicActivity_GrossDomesticProduction
- "Unemployment rate" ‚Üí UnemploymentRate_Person

**Step B: Geo-Tagging**: Identify the specific dcid for locations:
- Countries use format: country/USA, country/GBR, country/ARE, country/CHN
- India is: country/IND

**Step C: HS Code Identification**: If a product is mentioned, identify its HS Code category:
- Fish & Seafood ‚Üí HSCode03 / FishAndCrustaceansMolluscsAndOtherAquatic
- Spices, Tea, Coffee ‚Üí HSCode09 / CoffeeTeaMateAndSpices
- Textiles/Apparel ‚Üí HSCode61-62 / ArticlesOfApparelAndClothingAccessories
- Rice/Cereals ‚Üí HSCode10 / Cereals
- Gems & Jewelry ‚Üí HSCode71

**Step D: Refined Search String**: Construct a query for search_indicators that combines the sector, metric, and geography (e.g., "Export value of fish products from India", "Growth rate of exports to UAE").

### 3. Tool-Specific Guidelines

**search_indicators**: Never use single keywords. Use multi-dimensional queries like:

**For Exports (EIDB):**
- "Export value of cereals from India"
- "Growth rate of exports to United States"
- "Share of textile exports in total Indian exports"

**For CPI/Inflation (MOSPI):**
- "Consumer price index cereals India"
- "Inflation rate vegetables rural"
- "CPI food and beverages urban"

**For Public Data:**
- "Population of India"
- "GDP growth rate India"
- "Literacy rate by state in India"

**get_observations**: Always attempt to fetch historical context. Set date="all" to compare 2020 vs 2021 and identify growth trends.

**Fallback Protocol**: If Data Commons returns an empty set, try these alternatives:
- For exports: Try different commodity categories (HS codes) or destination countries
- For CPI/inflation: Try different categories (food, clothing, health, fuel, housing)
- For demographics: Try country-level if state-level is unavailable, or vice versa
- State clearly which data source was searched and suggest alternative queries

**Data Type Not Available Protocol**: If the user asks for a data type that doesn't exist in this database:
- Example: User asks for "food expenditure" but only CPI (price index) data exists
- Response format:
  1. Clearly state: "The specific data type you requested (expenditure) is not available in this database."
  2. Explain what related data IS available: "However, I have Consumer Price Index (CPI) data which tracks how food prices have changed over time."
  3. Offer an alternative: "Would you like to see the food price index trends or inflation rates instead?"
- NEVER fabricate data or perform meaningless calculations (like CPI √∑ population)

### 4. Correlation & Insights

Don't just provide a single number; provide a **Business Narrative**. Automatically look for correlations:

- **Market Diversification**: Compare export shares across multiple destination countries to assess market concentration risk
- **Growth vs. Volume**: Link absolute export values with growth rates - high growth on low base vs. steady growth on high base
- **Commodity Competitiveness**: Compare India's export share for a commodity against global demand indicators
- **Top Markets**: When discussing a commodity, identify the top 3 destination countries for that HS Code
- **Cross-Dataset Insights**: Correlate export performance with economic indicators (GDP, inflation, population) to provide comprehensive business context
  - Example: "India's agricultural exports grew 12% while food CPI inflation was 6.5%, indicating strong external demand"
  - Example: "Textile exports to USA increased alongside 8% population growth in target demographics"

### 5. Rich Formatting & Indian Business Context

**Currency & Scale**: All values are in INR. Convert to Indian standard units:
- Lakhs (‚Çπ1,00,000), Crores (‚Çπ1,00,00,000)
- Use format: **‚Çπ2,380 Cr** or **‚Çπ47,334 Cr**

**Visualizations**: Always trigger the dc-chart-container if you have a time series (2020 vs 2021) or more than 3 data points.

**Visual Scannability**:
- Use **Bold** for metrics (e.g., **‚Çπ28,916 Cr**, **23.69% growth**)
- Use *Italics* for Government schemes (*MEIS*, *RoDTEP*, *Udyam Registration*)
- Use bullet points for country/commodity lists

### 6. Strategic Follow-ups (The Business Expansion Path)

Conclude every response with a section titled:

üìà **Business Expansion Path**

Ask 3 targeted questions that move the user from 'Information' to 'Action':
- "Would you like to see which countries are the fastest-growing markets for this commodity?"
- "Shall we compare your product's export performance against competing categories?"
- "Would you like to identify the top 5 export destinations for your HS Code to plan market entry?"`,

        kb: `## Data Agent: Policy & Compliance Intelligence

**Current Date & Time**: {{CURRENT_DATETIME}}

### Role: Policy & Compliance Expert (India Regulatory Specialist)

You are Data Agent's Policy Wing - a legal compliance specialist for Indian businesses. Your purpose is to provide factual, actionable answers based strictly on the policy documents in your filestore.

### Default Context: INDIA
All queries are in the Indian regulatory context. Assume the user is asking about Indian MSME policies, schemes, and regulations unless otherwise specified.

### Available Policy Documents
Your filestore contains official Government of India documents including:
- **MSME Schemes**: PMEGP, CGTMSE, CLCSS, SFURTI, A-TUFS
- **Export-Import Policies**: Foreign Trade Policy, RoDTEP, MEIS, Advance Authorization
- **Registration & Compliance**: Udyam Registration, GST for MSMEs, FSSAI, BIS
- **Finance & Credit**: Priority Sector Lending, MUDRA, Stand-Up India, CGTMSE

### 1. Mandatory Step: Query Classification

Before responding, classify the query:
- **Scheme Eligibility**: Who qualifies? What are the criteria?
- **Process/Procedure**: How to apply? What documents needed?
- **Benefits/Incentives**: What subsidies, grants, or tax benefits?
- **Compliance/Deadlines**: What are the requirements and timelines?

### 2. Compliance Logic

**MSME Tiering**: Always identify and filter advice by enterprise category:
| Category | Investment (Mfg/Services) | Turnover |
|----------|---------------------------|----------|
| Micro | Up to ‚Çπ1 Cr | Up to ‚Çπ5 Cr |
| Small | Up to ‚Çπ10 Cr | Up to ‚Çπ50 Cr |
| Medium | Up to ‚Çπ50 Cr | Up to ‚Çπ250 Cr |

**Document Triangulation**: Connect related schemes (e.g., "Use *PMEGP* for setup capital + *CGTMSE* for collateral-free working capital + *RoDTEP* for export incentives").

### 3. Grounding & Citations

**Source Integrity**: Every fact must be traceable to a specific document. Format citations as: [Source: Document Name, Section/Page]

**Anti-Hallucination Protocol**: If information is not in the PDFs, state clearly:
> "This specific policy detail is not in our document library. For the latest information, please check the official ministry website or contact the relevant authority."

### 4. Rich Formatting & Output Structure

**For Scheme Information**:
- üìã **Scheme Name**: Full name and ministry
- üéØ **Objective**: One-line purpose
- ‚úÖ **Eligibility**: Bullet points
- üí∞ **Benefits**: Specific amounts in ‚Çπ (Lakhs/Crores)
- üìù **How to Apply**: Step-by-step process
- ‚è∞ **Deadlines**: If any, in **bold**
- üîó **Official Link**: If available

**Visual Formatting**:
- Use **Bold** for amounts, percentages, and deadlines
- Use *Italics* for scheme names and official terms
- Use tables for comparing multiple schemes
- Use bullet points for eligibility criteria and document lists
- Use numbered lists for step-by-step processes

### 5. Strategic Follow-ups

Conclude with:

üìã **Next Steps for Your Business**

Suggest 2-3 actionable follow-ups:
- "Would you like me to compare this scheme with similar alternatives?"
- "Shall I outline the complete document checklist for application?"
- "Do you want to understand how this scheme works with your export plans?"`,

        synthesis: `## Data Agent: Unified Intelligence Response

**Current Date & Time**: {{CURRENT_DATETIME}}

### Role: Strategic Intelligence Synthesizer

You are Data Agent, synthesizing insights from both **Statistical Data** and **Policy Documents** into a unified, actionable response.

### Your Task
Combine statistical data with policy information to create a comprehensive business narrative. Do NOT use labels like "From Data Commons" or "From Policy Documents" - weave the information naturally.

### Response Structure

**Opening**: Start with a direct answer to the user's question in 1-2 sentences.

**Data Insights Section** (if data available):
- Present key statistics with proper formatting (‚Çπ in Lakhs/Crores)
- Highlight trends (growth rates, market share changes)
- Use comparative analysis where relevant

**Policy & Scheme Context** (if policy info available):
- Connect data insights to relevant government schemes
- Highlight applicable benefits and incentives
- Mention eligibility criteria briefly

**Rich Formatting Rules**:
- **Bold** for all numerical values: **‚Çπ2,380 Cr**, **23.69% growth**, **Top 5 markets**
- *Italics* for scheme names: *PMEGP*, *RoDTEP*, *Udyam Registration*
- Use bullet points for lists
- Use tables for comparisons (if comparing 3+ items)
- Use > blockquotes for important policy highlights or warnings

**Indian Context**:
- All currency in ‚Çπ (Lakhs, Crores)
- Reference Indian fiscal years where relevant (FY 2020-21)
- Mention relevant ministries (MoCI, MoMSME)

### Closing Section - Clickable Follow-Up Suggestions (MANDATORY)

End EVERY response with exactly 3 clickable follow-up suggestions. These will be rendered as clickable text links.

**CRITICAL FORMATTING RULES:**
1. Start with the heading: **Follow up questions:**
2. Use the EXACT format: \`[suggestion: Your query text here]\`
3. Write as **direct commands/queries** (imperative), NOT as questions
4. Do NOT use "Shall I...", "Would you like...", "Do you want..." - these are NOT clickable
5. Keep suggestions concise (under 60 characters ideally)
6. Put each suggestion on its own line, NO bullet points or dashes before them

**‚úÖ CORRECT Format (Direct Commands):**
\`[suggestion: Compare rural vs urban food inflation]\`
\`[suggestion: Show vegetable price trends since 2020]\`
\`[suggestion: Which category has the highest inflation?]\`

**‚ùå WRONG Format (Conversational Questions):**
- "Would you like to see rural vs urban comparison?" ‚Üê WRONG
- "Shall I show the inflation trend?" ‚Üê WRONG
- "Do you want to compare categories?" ‚Üê WRONG

**Follow-Up Suggestion Ideas by Topic:**

**If query was about CPI/Prices:**
- \`[suggestion: Compare rural vs urban CPI for {category}]\`
- \`[suggestion: Show {category} inflation rate trend]\`
- \`[suggestion: Compare {category} with {related_category} prices]\`

**If query was about Inflation:**
- \`[suggestion: Show underlying CPI index for {category}]\`
- \`[suggestion: Compare {category} inflation rural vs urban]\`
- \`[suggestion: Which sub-category drives {category} inflation?]\`

**If query was about specific category:**
- \`[suggestion: Show {category} trend from 2020 to 2024]\`
- \`[suggestion: Compare {category} rural vs urban]\`
- \`[suggestion: Compare {category} with {related_category}]\`

**Available MOSPI Categories for Suggestions:**
- Food: Food, Cereals, Vegetables, Fruits, Meat & Fish, Eggs, Milk, Oils & Fats, Pulses, Sugar, Spices
- Non-Food: Clothing, Fuel & Light, Health, Education, Transport, Recreation, Household Goods, Personal Care
- Areas: Rural, Urban, Combined

**Example Output:**
\`\`\`
**Follow up questions:**
[suggestion: Compare rural vs urban vegetable inflation]
[suggestion: Show food price index trend since 2020]
[suggestion: Which food category has highest inflation?]
\`\`\`

### Important Guidelines
- Prioritize actionable insights over raw data
- Connect export opportunities with available policy support
- Always maintain Indian business context
- ALWAYS end with 3 specific, data-driven follow-up questions`
      }
    };
  </script>
  <style>
    /* Google Brand Colors + Data Agent Portal Styles */
    :root {
      /* Google Brand Colors */
      --google-blue: #4285F4;
      --google-red: #EA4335;
      --google-yellow: #FBBC04;
      --google-green: #34A853;
      --google-grey: #3C4043;
      --google-grey-500: #9AA0A6;

      /* Primary UI Colors (using Google palette) */
      --gov-blue: #4285F4;
      --gov-blue-light: #5a95f5;
      --gov-blue-dark: #3367d6;
      --saffron: #FBBC04;
      --white: #FFFFFF;
      --green: #34A853;
      --chakra-blue: #4285F4;
      --text-dark: #3C4043;
      --text-muted: #9AA0A6;
      --bg-light: #f8f9fa;
      --border-color: #dadce0;
      --success: #34A853;
      --warning: #FBBC04;
      --danger: #EA4335;
    }

    * {
      box-sizing: border-box;
    }

    /* Full Page Layout - 3 Column */
    #homepage,
    #homepage.main-content {
      display: flex;
      flex-direction: column;
      height: calc(100vh - 56px);
      padding: 0 !important;
      margin: 0 !important;
      overflow: hidden;
    }

    /* App Container - 3 columns */
    .app-container {
      display: flex;
      flex: 1;
      overflow: hidden;
      height: 100%;
      margin: 0;
      padding: 0;
    }

    /* Left Sidebar - Tool Calls */
    .left-sidebar {
      width: 320px;
      background: #f8f9fa;
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      margin-left: 0;
      transition: margin-left 0.3s ease;
    }

    .left-sidebar.hidden {
      margin-left: -320px;
    }

    .sidebar-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 16px;
      background: var(--gov-blue);
      color: white;
      font-weight: 600;
      font-size: 0.9rem;
    }

    .sidebar-header svg {
      flex-shrink: 0;
    }

    .sidebar-close {
      margin-left: auto;
      background: none;
      border: none;
      color: white;
      font-size: 1.5rem;
      cursor: pointer;
      line-height: 1;
      padding: 0;
    }

    .tool-calls-container {
      flex: 1;
      overflow-y: auto;
      padding: 12px;
    }

    .tool-calls-empty {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .tool-call-item {
      background: white;
      border: 1px solid var(--border-color);
      border-left: 3px solid var(--gov-blue);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 10px;
      font-size: 0.8rem;
    }

    .tool-call-item.loading {
      border-left-color: var(--saffron);
      animation: pulse 1.5s infinite;
    }

    .tool-call-item.success {
      border-left-color: var(--green);
    }

    .tool-call-item.error {
      border-left-color: var(--danger);
    }

    .tool-call-name {
      font-weight: 600;
      color: var(--gov-blue);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .tool-call-name .badge {
      font-size: 0.65rem;
      padding: 2px 6px;
      border-radius: 10px;
      background: var(--saffron);
      color: white;
      font-weight: 500;
    }

    .tool-call-args {
      background: #f1f3f4;
      padding: 8px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 0.7rem;
      word-break: break-all;
      margin-bottom: 8px;
      max-height: 80px;
      overflow-y: auto;
    }

    .tool-call-result {
      color: var(--text-muted);
      font-size: 0.75rem;
      max-height: 100px;
      overflow-y: auto;
    }

    .tool-call-result.success {
      color: var(--green);
    }

    .tool-call-result.error {
      color: var(--danger);
    }

    /* Main Content Area */
    .main-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
      min-height: 0;
      overflow: hidden;
      height: 100%;
    }

    /* Right Sidebar - Settings */
    .right-sidebar {
      width: 320px;
      background: white;
      border-left: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
      margin-right: 0;
      transition: margin-right 0.3s ease;
    }

    .right-sidebar.hidden {
      margin-right: -320px;
    }

    .right-sidebar .settings-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
    }

    .config-section {
      margin-bottom: 20px;
    }

    .config-section label {
      display: block;
      font-weight: 600;
      font-size: 0.8rem;
      color: var(--gov-blue);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .config-section input[type="text"],
    .config-section input[type="password"] {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      font-size: 0.85rem;
      font-family: inherit;
    }

    .config-section input:focus {
      outline: none;
      border-color: var(--gov-blue);
      box-shadow: 0 0 0 3px rgba(0, 51, 102, 0.1);
    }

    .config-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 6px;
    }

    .config-toggle span:first-child {
      flex: 1;
      font-size: 0.85rem;
      color: var(--text-dark);
    }

    .status-badge {
      font-size: 0.7rem;
      padding: 3px 8px;
      border-radius: 12px;
      background: #dc3545;
      color: white;
      font-weight: 500;
    }

    .status-badge.active {
      background: var(--green);
    }

    /* Toggle Switch */
    .switch {
      position: relative;
      display: inline-block;
      width: 44px;
      height: 24px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #ccc;
      transition: 0.3s;
      border-radius: 24px;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 3px;
      background-color: white;
      transition: 0.3s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: var(--gov-blue);
    }

    input:checked + .slider:before {
      transform: translateX(20px);
    }

    .btn-primary {
      width: 100%;
      background: var(--gov-blue);
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
      margin-top: 10px;
    }

    .btn-primary:hover {
      background: var(--gov-blue-light);
    }

    .config-status {
      text-align: center;
      margin-top: 10px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .config-help {
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid var(--border-color);
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .config-help p {
      margin: 0 0 8px 0;
    }

    .config-help a {
      color: var(--gov-blue);
      text-decoration: none;
    }

    .config-help a:hover {
      text-decoration: underline;
    }

    .config-help code {
      background: #e9ecef;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.7rem;
      word-break: break-all;
    }

    /* Prompt Editor Sections */
    .prompt-section {
      margin-bottom: 16px;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      overflow: hidden;
    }

    .prompt-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      background: #f8f9fa;
      cursor: pointer;
      user-select: none;
    }

    .prompt-header:hover {
      background: #e9ecef;
    }

    .prompt-header label {
      margin: 0;
      cursor: pointer;
      font-size: 0.8rem;
    }

    .prompt-arrow {
      font-size: 0.7rem;
      transition: transform 0.2s;
    }

    .prompt-section:not(.collapsed) .prompt-arrow {
      transform: rotate(90deg);
    }

    .prompt-textarea {
      width: 100%;
      min-height: 150px;
      max-height: 300px;
      padding: 10px 12px;
      border: none;
      border-top: 1px solid var(--border-color);
      font-size: 0.75rem;
      font-family: monospace;
      resize: vertical;
      line-height: 1.4;
    }

    .prompt-textarea:focus {
      outline: none;
      background: #fffdf0;
    }

    .prompt-section.collapsed .prompt-textarea {
      display: none;
    }

    /* Edge Toggle Tab - Base */
    .edge-toggle-tab {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 12px 6px;
      background: var(--gov-blue);
      color: white;
      border: none;
      cursor: pointer;
      z-index: 101;
      transition: background 0.2s ease;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    }

    .edge-toggle-tab svg {
      width: 16px;
      height: 16px;
      transition: transform 0.3s ease;
    }

    .edge-toggle-tab .tab-label {
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 11px;
      font-weight: 600;
      margin-top: 8px;
      letter-spacing: 1px;
      text-transform: uppercase;
    }

    /* Left Tab (Tools) */
    .left-toggle-tab {
      left: 0;
      border-radius: 0 8px 8px 0;
    }

    .left-toggle-tab svg {
      transform: rotate(0deg); /* Points right when closed */
    }

    .left-toggle-tab.open svg {
      transform: rotate(180deg); /* Points left when open */
    }

    /* Right Tab (Settings) */
    .right-toggle-tab {
      right: 0;
      border-radius: 8px 0 0 8px;
    }

    .right-toggle-tab svg {
      transform: rotate(180deg); /* Points left when closed */
    }

    .right-toggle-tab.open svg {
      transform: rotate(0deg); /* Points right when open */
    }

    /* Hover effect */
    .edge-toggle-tab:hover {
      background: var(--gov-blue-light);
    }

    /* Chat Area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: 0;
      border: none;
      border-left: 1px solid var(--border-color);
      border-right: 1px solid var(--border-color);
      overflow: hidden;
      min-height: 0;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
      min-height: 0;
    }

    .message {
      margin-bottom: 20px;
      display: flex;
      gap: 12px;
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: var(--gov-blue);
      color: white;
    }

    .message.assistant .message-avatar {
      background: linear-gradient(135deg, var(--saffron) 0%, var(--green) 100%);
      color: white;
    }

    .message-content {
      max-width: 70%;
      padding: 14px 18px;
      border-radius: 12px;
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .message.user .message-content {
      background: var(--gov-blue);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .message.assistant .message-content {
      background: white;
      color: var(--text-dark);
      border-bottom-left-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      border: 1px solid #e9ecef;
    }

    .message-content p {
      margin: 0 0 10px 0;
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 14px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 10px 0;
      font-size: 0.85rem;
    }

    .message-content code {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.9em;
    }

    .message.user .message-content code {
      background: rgba(255,255,255,0.2);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .message.assistant .message-content code:not(pre code) {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 3px;
      color: var(--gov-blue);
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    /* Static Branding Header - Compact Horizontal */
    .branding-header {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      padding: 10px 20px;
      background: white;
      border-bottom: 1px solid var(--border-color);
      flex-shrink: 0;
      transition: opacity 0.3s ease, filter 0.3s ease;
    }

    .branding-header.inactive {
      opacity: 0.4;
      filter: grayscale(50%);
      pointer-events: none;
    }

    .branding-header .branding-icon {
      width: 40px;
      height: 40px;
      background: linear-gradient(135deg, var(--saffron) 0%, var(--green) 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 700;
      color: white;
      text-decoration: none;
      transition: transform 0.2s, box-shadow 0.2s;
      flex-shrink: 0;
    }

    .branding-header:not(.inactive) .branding-icon:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .branding-header .branding-text {
      display: flex;
      flex-direction: column;
      line-height: 1.3;
    }

    .branding-header h2 {
      color: var(--gov-blue);
      margin: 0;
      font-size: 1.1rem;
      font-weight: 600;
    }

    .branding-header .branding-tagline {
      color: var(--text-muted);
      margin: 0;
      font-size: 0.75rem;
    }

    .branding-status {
      display: none;
      font-size: 0.7rem;
      color: var(--warning);
      margin-left: 8px;
    }

    .branding-header.inactive .branding-status {
      display: inline;
    }

    /* Welcome Message - Suggestions Only */
    .welcome-message {
      text-align: center;
      padding: 30px 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
    }

    .welcome-message .suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      max-width: 700px;
    }

    .welcome-message .suggestion {
      background: white;
      border: 2px solid var(--border-color);
      border-radius: 24px;
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
      color: var(--text-dark);
    }

    .welcome-message .suggestion:hover:not(:disabled) {
      border-color: var(--gov-blue);
      background: #f0f7ff;
      color: var(--gov-blue);
    }

    .welcome-message .suggestion:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Follow-up Suggestion Links (in assistant messages) */
    .followup-suggestion {
      display: block;
      background: none;
      border: none;
      padding: 0;
      margin: 1px 0;
      cursor: pointer;
      font-size: 0.9rem;
      font-family: inherit;
      text-align: left;
      text-decoration: none;
      color: #4285F4; /* Google Blue */
      transition: opacity 0.2s ease;
    }

    .followup-suggestion:hover {
      opacity: 0.7;
      text-decoration: underline;
    }

    .followup-suggestion:active {
      opacity: 0.6;
    }

    /* Follow-up questions container - appears at end of message */
    .followup-container {
      margin-top: 16px;
      padding-top: 12px;
      border-top: 1px solid #e9ecef;
    }

    .followup-container .followup-heading {
      font-weight: 600;
      color: var(--text-dark);
      margin-bottom: 4px;
      font-size: 0.9rem;
    }

    /* Chat Input Area */
    .chat-input-area {
      background: white;
      border-top: 1px solid var(--border-color);
      padding: 16px 24px;
      flex-shrink: 0;
    }

    .chat-input-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .chat-input-wrapper {
      flex: 1;
    }

    #chat-input {
      width: 100%;
      border: 2px solid var(--border-color);
      border-radius: 24px;
      padding: 14px 22px;
      font-size: 1rem;
      resize: none;
      min-height: 52px;
      max-height: 150px;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      font-family: inherit;
    }

    #chat-input:focus {
      border-color: var(--gov-blue);
      box-shadow: 0 0 0 4px rgba(0, 51, 102, 0.1);
    }

    #chat-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    #send-btn {
      background: var(--gov-blue);
      color: white;
      border: none;
      border-radius: 50%;
      width: 52px;
      height: 52px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    #send-btn:hover:not(:disabled) {
      background: var(--gov-blue-light);
      transform: scale(1.05);
    }

    #send-btn:disabled {
      background: #adb5bd;
      cursor: not-allowed;
    }

    #send-btn svg {
      width: 22px;
      height: 22px;
    }

    /* Typing Indicator */
    .typing-indicator {
      display: flex;
      gap: 5px;
      padding: 14px 18px;
    }

    .typing-indicator span {
      width: 10px;
      height: 10px;
      background: var(--gov-blue);
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-10px); opacity: 1; }
    }

    /* Streaming cursor animation */
    .streaming-cursor {
      display: inline-block;
      animation: blink 0.8s infinite;
      color: var(--gov-blue);
      font-weight: normal;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Error Message */
    .error-message {
      background: #fdf2f2;
      color: var(--danger);
      padding: 14px 18px;
      border-radius: 8px;
      margin-bottom: 16px;
      border: 1px solid #fecaca;
      border-left: 4px solid var(--danger);
    }

    /* Google Data Commons Footer */
    .google-footer {
      background: #ffffff;
      border-top: 1px solid var(--border-color);
      padding: 16px 24px;
      text-align: center;
      flex-shrink: 0;
    }

    .google-footer-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .google-logo {
      display: inline-flex;
      align-items: center;
      font-weight: 500;
      letter-spacing: -0.5px;
    }

    .google-logo .g-blue { color: #4285F4; }
    .google-logo .g-red { color: #EA4335; }
    .google-logo .g-yellow { color: #FBBC05; }
    .google-logo .g-green { color: #34A853; }

    .google-footer a {
      color: #4285F4;
      text-decoration: none;
      font-weight: 500;
    }

    .google-footer a:hover {
      text-decoration: underline;
    }

    /* Responsive - 3 Column Layout */
    @media (max-width: 1200px) {
      .left-sidebar {
        width: 280px;
      }
      .right-sidebar {
        width: 280px;
      }
    }

    @media (max-width: 992px) {
      /* Make sidebars fixed overlays on tablets */
      .left-sidebar {
        position: fixed;
        top: 56px;
        left: 0;
        bottom: 0;
        z-index: 100;
        box-shadow: 4px 0 20px rgba(0,0,0,0.1);
        margin-left: 0;
        transform: translateX(0);
        transition: transform 0.3s ease;
      }

      .left-sidebar.hidden {
        transform: translateX(-100%);
        margin-left: 0;
      }

      .right-sidebar {
        position: fixed;
        top: 56px;
        right: 0;
        bottom: 0;
        z-index: 100;
        box-shadow: -4px 0 20px rgba(0,0,0,0.1);
        margin-right: 0;
        transform: translateX(0);
        transition: transform 0.3s ease;
      }

      .right-sidebar.hidden {
        transform: translateX(100%);
        margin-right: 0;
      }

      .message-content {
        max-width: 85%;
      }
    }

    @media (max-width: 768px) {
      #homepage {
        height: calc(100vh - 50px);
      }

      /* Make sidebars full-width overlays on mobile */
      .left-sidebar,
      .right-sidebar {
        width: 100%;
        max-width: 320px;
      }

      /* Smaller branding header on mobile */
      .branding-header {
        padding: 8px 12px;
        gap: 10px;
      }

      .branding-header .branding-icon {
        width: 36px;
        height: 36px;
        font-size: 16px;
      }

      .branding-header h2 {
        font-size: 0.95rem;
      }

      .branding-header .branding-tagline {
        font-size: 0.7rem;
      }

      .branding-status {
        display: none !important;
      }

      /* Edge toggle tabs on mobile - smaller */
      .edge-toggle-tab {
        padding: 8px 4px;
      }

      .edge-toggle-tab .tab-label {
        font-size: 10px;
      }

      .chat-messages {
        padding: 16px;
      }

      .message-content {
        max-width: 90%;
        padding: 12px 14px;
        font-size: 0.9rem;
      }

      .message-avatar {
        width: 32px;
        height: 32px;
        font-size: 12px;
      }

      .welcome-message {
        padding: 30px 16px;
      }

      .welcome-message h2 {
        font-size: 1.2rem;
      }

      .welcome-message p {
        font-size: 0.9rem;
      }

      .welcome-message .suggestions {
        flex-direction: column;
        align-items: stretch;
      }

      .welcome-message .suggestion {
        text-align: left;
        font-size: 0.85rem;
        padding: 12px 16px;
      }

      .chat-input-area {
        padding: 12px 16px;
      }

      #chat-input {
        padding: 12px 18px;
        font-size: 0.95rem;
        min-height: 46px;
      }

      #send-btn {
        width: 46px;
        height: 46px;
      }

      .google-footer {
        padding: 12px 16px;
      }

      .google-footer-content {
        font-size: 0.8rem;
        flex-wrap: wrap;
      }
    }

    @media (max-width: 480px) {
      .welcome-icon {
        width: 60px;
        height: 60px;
        font-size: 28px;
      }

      .tool-call-args {
        font-size: 0.75rem;
        padding: 6px 10px;
      }
    }

    /* Data Commons Chart Styles */
    .dc-chart-container {
      background: #ffffff;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
      min-height: 300px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.06);
    }

    .dc-chart-container.loading {
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
    }

    .dc-chart-container.loading::after {
      content: 'Loading visualization...';
      animation: pulse 1.5s infinite;
    }

    .dc-chart-container datacommons-line,
    .dc-chart-container datacommons-bar,
    .dc-chart-container datacommons-map,
    .dc-chart-container datacommons-highlight {
      --dc-headings-font-family: inherit;
      --dc-font-family: inherit;
      width: 100%;
      min-height: 280px;
    }

    .message-content .dc-chart-container {
      max-width: 100%;
      overflow-x: auto;
    }

    .dc-chart-error {
      background: #fdf2f2;
      border: 1px solid #fecaca;
      border-radius: 8px;
      padding: 16px;
      margin-top: 16px;
      color: var(--danger);
      font-size: 0.9rem;
    }

    .dc-chart-title {
      font-size: 0.95rem;
      font-weight: 600;
      color: var(--gov-blue);
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 2px solid var(--saffron);
    }

    .dc-chart-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid var(--border-color);
      font-size: 0.8rem;
      color: var(--text-muted);
      flex-wrap: wrap;
      gap: 8px;
    }

    .dc-chart-unit {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .dc-chart-source {
      font-size: 0.75rem;
      color: var(--text-muted);
    }

    .dc-chart-source a {
      color: var(--gov-blue);
      text-decoration: none;
    }

    .dc-chart-source a:hover {
      text-decoration: underline;
    }
  </style>
{% endblock %}

{% block content %}
  <!-- App Container with 3-column layout -->
  <div class="app-container">
    <!-- Left Sidebar - Tool Calls -->
    <aside class="left-sidebar" id="left-sidebar">
      <div class="sidebar-header">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"/>
        </svg>
        <span>Tool Activity</span>
        <button class="sidebar-close" id="close-tools">√ó</button>
      </div>
      <div class="tool-calls-container" id="tool-calls-container">
        <div class="tool-calls-empty">
          <p>Tool calls will appear here when you ask data questions</p>
        </div>
      </div>
    </aside>

    <!-- Main Chat Area -->
    <main class="main-content">
      <!-- Static Branding Header -->
      <div class="branding-header inactive" id="branding-header">
        <a href="/" class="branding-icon">DA</a>
        <div class="branding-text">
          <h2>Data <span style="color: var(--saffron);">Agent</span></h2>
          <p class="branding-tagline">Your Intelligent Companion | ‡§Ü‡§™‡§ï‡§æ ‡§¨‡•Å‡§¶‡•ç‡§ß‡§ø‡§Æ‡§æ‡§® ‡§∏‡§π‡§æ‡§Ø‡§ï</p>
        </div>
        <span class="branding-status">‚Ä¢ Configure settings</span>
      </div>

      <div class="chat-area">
        <div class="chat-messages" id="chat-messages">
          <div class="welcome-message" id="welcome-message">
            <div class="suggestions">
              <button class="suggestion" data-text="Compare rural vs urban food inflation" disabled>Compare rural vs urban food inflation</button>
              <button class="suggestion" data-text="Which category has highest inflation?" disabled>Which category has highest inflation?</button>
            </div>
          </div>
        </div>

        <div class="chat-input-area">
          <div class="chat-input-row">
            <div class="chat-input-wrapper">
              <textarea
                id="chat-input"
                placeholder="Configure settings to start chatting..."
                rows="1"
                disabled
              ></textarea>
            </div>
            <button id="send-btn" title="Send message" disabled>
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <!-- Google Data Commons Footer -->
      <footer class="google-footer">
        <div class="google-footer-content">
          <span>Powered by</span>
          <span class="google-logo">
            <span class="g-blue">G</span><span class="g-red">o</span><span class="g-yellow">o</span><span class="g-blue">g</span><span class="g-green">l</span><span class="g-red">e</span>
          </span>
          <a href="https://datacommons.org" target="_blank" rel="noopener">Data Commons</a>
        </div>
      </footer>
    </main>

    <!-- Right Sidebar - Settings -->
    <aside class="right-sidebar" id="right-sidebar">
      <div class="sidebar-header">
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="12" cy="12" r="3"></circle>
          <path d="M12 1v2M12 21v2M4.22 4.22l1.42 1.42M18.36 18.36l1.42 1.42M1 12h2M21 12h2M4.22 19.78l1.42-1.42M18.36 5.64l1.42-1.42"/>
        </svg>
        <span>Settings</span>
        <button class="sidebar-close" id="close-settings">√ó</button>
      </div>
      <div class="settings-content" id="settings-content">
        <div class="config-section">
          <label for="api-key-input">Gemini API Key</label>
          <input type="password" id="api-key-input" placeholder="Enter your Gemini API key">
        </div>

        <div class="config-section">
          <label for="mcp-url-input">MCP Proxy URL</label>
          <input type="text" id="mcp-url-input" placeholder="http://localhost:5001" value="http://localhost:5001">
          <div class="config-toggle">
            <span>MCP Tools</span>
            <span class="status-badge" id="mcp-status">Disconnected</span>
            <label class="switch">
              <input type="checkbox" id="mcp-enabled" checked>
              <span class="slider"></span>
            </label>
          </div>
        </div>

        <div class="config-section">
          <label for="kb-store-input">Knowledge Base</label>
          <input type="text" id="kb-store-input" placeholder="fileSearchStores/your-store-id" value="fileSearchStores/msmepolicies-8pibj9lwmrws">
          <div class="config-toggle">
            <span>Knowledge Base</span>
            <span class="status-badge active" id="kb-status">Active</span>
            <label class="switch">
              <input type="checkbox" id="kb-enabled" checked>
              <span class="slider"></span>
            </label>
          </div>
        </div>

        <div class="prompt-section collapsed" id="mcp-prompt-section">
          <div class="prompt-header" onclick="togglePromptSection('mcp-prompt-section')">
            <span class="prompt-arrow">‚ñ∂</span>
            <label>MCP System Prompt</label>
          </div>
          <textarea id="mcp-prompt-input" class="prompt-textarea" placeholder="MCP system instructions..."></textarea>
        </div>

        <div class="prompt-section collapsed" id="kb-prompt-section">
          <div class="prompt-header" onclick="togglePromptSection('kb-prompt-section')">
            <span class="prompt-arrow">‚ñ∂</span>
            <label>KB System Prompt</label>
          </div>
          <textarea id="kb-prompt-input" class="prompt-textarea" placeholder="KB system instructions..."></textarea>
        </div>

        <div class="prompt-section collapsed" id="synthesis-prompt-section">
          <div class="prompt-header" onclick="togglePromptSection('synthesis-prompt-section')">
            <span class="prompt-arrow">‚ñ∂</span>
            <label>Synthesis Prompt</label>
          </div>
          <textarea id="synthesis-prompt-input" class="prompt-textarea" placeholder="Synthesis/combining instructions..."></textarea>
        </div>

        <button class="btn-primary" id="save-config">Save and Connect</button>
        <div class="config-status" id="config-status"></div>

        <div class="config-help">
          <!-- <p>Get Gemini key from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>.</p> -->
          <!-- <p>Run MCP proxy: <code>python additional_features/mcp_proxy_server.py</code></p> -->
        </div>
      </div>
    </aside>
  </div>

  <!-- Left Edge Toggle Tab (Tools) -->
  <button class="edge-toggle-tab left-toggle-tab open" id="tools-toggle" title="Toggle Tool Activity">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
    <span class="tab-label">Tools</span>
  </button>

  <!-- Right Edge Toggle Tab (Settings) -->
  <button class="edge-toggle-tab right-toggle-tab open" id="settings-toggle" title="Toggle Settings">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"></polyline>
    </svg>
    <span class="tab-label">Settings</span>
  </button>

  <script>
    (function() {
      // Configuration from external config file
      const config = window.CHAT_CONFIG;

      // Debug: Check if config loaded
      if (!config) {
        console.error('‚ùå CHAT_CONFIG not loaded! Check if chat-config.js is accessible.');
        console.error('Expected path: /static/custom_dc/custom/chat-config.js');
      } else {
        console.log('‚úÖ CHAT_CONFIG loaded successfully:', config);
      }

      const GEMINI_API_BASE = config?.api?.GEMINI_API_BASE || 'https://generativelanguage.googleapis.com/v1beta/models';
      const MCP_MODEL = config?.models?.MCP_MODEL || 'gemini-3-flash-preview';
      const KB_MODEL = config?.models?.KB_MODEL || 'gemini-3-flash-preview';

      // Helper function to get current date/time in Indian format
      function getCurrentDateTimeIST() {
        const now = new Date();
        const options = {
          timeZone: 'Asia/Kolkata',
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric',
          hour: '2-digit',
          minute: '2-digit',
          hour12: true
        };
        return now.toLocaleString('en-IN', options) + ' IST';
      }

      // Helper function to inject current datetime into prompts
      function injectDateTime(prompt) {
        return prompt.replace('{{CURRENT_DATETIME}}', getCurrentDateTimeIST());
      }

      // System instructions - load from localStorage first, fallback to config defaults
      let mcpSystemInstruction = localStorage.getItem('mcp_system_prompt') || config?.systemInstructions?.mcp || '';
      let kbSystemInstruction = localStorage.getItem('kb_system_prompt') || config?.systemInstructions?.kb || '';
      let synthesisSystemInstruction = localStorage.getItem('synthesis_system_prompt') || config?.systemInstructions?.synthesis || '';

      // Console log configuration on load
      console.group('üîß Chat Configuration Loaded');
      console.log('API Base:', GEMINI_API_BASE);
      console.log('MCP Model:', MCP_MODEL);
      console.log('KB Model:', KB_MODEL);
      console.log('Default MCP Proxy URL:', config?.defaults?.mcpProxyUrl);
      console.log('Default KB Store ID:', config?.defaults?.kbStoreId);
      console.groupEnd();

      const mcpPromptSource = localStorage.getItem('mcp_system_prompt') ? 'localStorage' : 'default config';
      const kbPromptSource = localStorage.getItem('kb_system_prompt') ? 'localStorage' : 'default config';

      console.group('üìù MCP System Prompt (from ' + mcpPromptSource + ')');
      console.log('With DateTime:', injectDateTime(mcpSystemInstruction));
      console.groupEnd();

      console.group('üìù KB System Prompt (from ' + kbPromptSource + ')');
      console.log('With DateTime:', injectDateTime(kbSystemInstruction));
      console.groupEnd();

      const synthesisPromptSource = localStorage.getItem('synthesis_system_prompt') ? 'localStorage' : 'default config';
      console.group('üìù Synthesis System Prompt (from ' + synthesisPromptSource + ')');
      console.log('With DateTime:', injectDateTime(synthesisSystemInstruction));
      console.groupEnd();

      // State
      let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
      let mcpProxyUrl = localStorage.getItem('mcp_proxy_url') || config.defaults?.mcpProxyUrl || 'http://localhost:5001';
      let mcpEnabled = localStorage.getItem('mcp_enabled') !== 'false';
      let kbStoreId = localStorage.getItem('kb_store_id') || config.defaults?.kbStoreId || 'fileSearchStores/msmepolicies-8pibj9lwmrws';
      let kbEnabled = localStorage.getItem('kb_enabled') !== 'false';
      let mcpTools = [];
      let mcpConnected = false;
      let conversationHistory = [];
      let isProcessing = false;
      let lastChartAnalysis = null;
      let lastDataSource = null;  // Track the data source from MCP responses

      // Chart.js Script Loader
      let chartJsLoaded = false;
      let chartJsLoadPromise = null;

      function loadChartJs() {
        if (chartJsLoaded) return Promise.resolve();
        if (chartJsLoadPromise) return chartJsLoadPromise;

        chartJsLoadPromise = new Promise((resolve, reject) => {
          const script = document.createElement('script');
          script.src = 'https://cdn.jsdelivr.net/npm/chart.js';
          script.onload = () => {
            chartJsLoaded = true;
            console.log('Chart.js loaded');
            resolve();
          };
          script.onerror = () => reject(new Error('Failed to load Chart.js'));
          document.head.appendChild(script);
        });

        return chartJsLoadPromise;
      }

      // Chart Data Analyzer - extracts actual data from tool results for Chart.js
      function analyzeChartData(toolName, result) {
        if (toolName !== 'get_observations') return null;

        try {
          console.log('Analyzing chart data for tool:', toolName);
          console.log('Raw result:', result);

          const data = typeof result === 'string' ? JSON.parse(result) : result;
          console.log('Parsed data:', data);

          // Must have variable and place_observations
          if (!data.variable || !data.place_observations) {
            console.log('Missing variable or place_observations');
            return null;
          }

          const variableName = data.variable.name || data.variable.dcid;
          const places = data.place_observations;

          if (!places || places.length === 0) {
            console.log('No places found');
            return null;
          }

          // Extract time series data
          const datasets = [];
          let labels = [];

          for (const placeData of places) {
            const placeName = placeData.place?.name || placeData.place?.dcid || 'Unknown';
            const timeSeries = placeData.time_series || [];

            console.log(`Place: ${placeName}, Time series points: ${timeSeries.length}`);

            if (timeSeries.length > 0) {
              // Extract labels (dates) from first place
              if (labels.length === 0) {
                labels = timeSeries.map(point => point[0]);
              }

              // Extract values
              const values = timeSeries.map(point => point[1]);

              // Smart label: use variableName if single place, placeName if multiple places
              // This ensures proper labels when comparing variables vs comparing places
              let datasetLabel;
              if (places.length === 1) {
                // Single place - use variable name (for comparing different variables)
                datasetLabel = variableName;
              } else {
                // Multiple places - use place name (for comparing same variable across places)
                datasetLabel = placeName;
              }

              datasets.push({
                label: datasetLabel,
                data: values,
                borderColor: getChartColor(datasets.length),
                backgroundColor: getChartColor(datasets.length, 0.2),
                tension: 0.1,
                fill: false
              });
            }
          }

          if (labels.length === 0 || datasets.length === 0) {
            console.log('No valid data points found');
            return null;
          }

          // Determine chart type
          const hasTimeSeries = labels.length > 1;
          const multiplePlaces = datasets.length > 1;
          let chartType = hasTimeSeries ? 'line' : 'bar';

          // Extract source metadata - fields from Data Commons MCP
          const sourceMetadata = data.source_metadata || {};
          const unit = sourceMetadata.unit || '';
          const sourceName = sourceMetadata.import_name || sourceMetadata.source_name || 'Data Commons';
          const sourceUrl = sourceMetadata.provenance_url || sourceMetadata.source_url || '';

          console.log('Chart analysis complete:', {
            chartType,
            variableName,
            labels,
            datasetsCount: datasets.length,
            unit,
            sourceName,
            sourceUrl
          });

          return {
            chartType,
            variableName,
            labels,
            datasets,
            unit,
            sourceName,
            sourceUrl
          };
        } catch (e) {
          console.error('Error analyzing chart data:', e);
          return null;
        }
      }

      // Merge chart data from multiple get_observations calls (for multi-curve charts)
      function mergeChartData(existing, newData) {
        if (!existing) return newData;
        if (!newData) return existing;

        console.log('Merging chart data:', {
          existingDatasets: existing.datasets.length,
          existingLabels: existing.labels.length,
          newDatasets: newData.datasets.length,
          newLabels: newData.labels.length
        });

        // Combine variable names if different
        let combinedVariableName = existing.variableName;
        if (newData.variableName && newData.variableName !== existing.variableName) {
          combinedVariableName = `${existing.variableName} vs ${newData.variableName}`;
        }

        // Merge labels (union of all dates, sorted)
        const allLabelsSet = new Set([...existing.labels, ...newData.labels]);
        const mergedLabels = Array.from(allLabelsSet).sort();

        // Reindex existing datasets to new merged labels
        const reindexedExisting = existing.datasets.map(ds => ({
          ...ds,
          data: mergedLabels.map(label => {
            const idx = existing.labels.indexOf(label);
            return idx !== -1 ? ds.data[idx] : null;
          })
        }));

        // Reindex new datasets to merged labels with new colors
        const colorOffset = existing.datasets.length;
        const reindexedNew = newData.datasets.map((ds, i) => ({
          ...ds,
          data: mergedLabels.map(label => {
            const idx = newData.labels.indexOf(label);
            return idx !== -1 ? ds.data[idx] : null;
          }),
          // Assign new colors to avoid duplicates
          borderColor: getChartColor(colorOffset + i),
          backgroundColor: getChartColor(colorOffset + i, 0.2)
        }));

        // Combine datasets
        const mergedDatasets = [...reindexedExisting, ...reindexedNew];

        // Combine source info (deduplicated)
        const sourceNames = [existing.sourceName, newData.sourceName]
          .filter((s, i, arr) => s && arr.indexOf(s) === i);

        console.log('Merged chart data:', {
          variableName: combinedVariableName,
          labelsCount: mergedLabels.length,
          datasetsCount: mergedDatasets.length,
          datasetLabels: mergedDatasets.map(ds => ds.label)
        });

        return {
          chartType: existing.chartType,
          variableName: combinedVariableName,
          labels: mergedLabels,
          datasets: mergedDatasets,
          unit: existing.unit || newData.unit,
          sourceName: sourceNames.join(' | '),
          sourceUrl: existing.sourceUrl || newData.sourceUrl
        };
      }

      // Chart color palette
      function getChartColor(index, alpha = 1) {
        const colors = [
          `rgba(0, 51, 102, ${alpha})`,   // Gov blue
          `rgba(255, 153, 51, ${alpha})`, // Saffron
          `rgba(19, 136, 8, ${alpha})`,   // Green
          `rgba(66, 133, 244, ${alpha})`, // Google blue
          `rgba(234, 67, 53, ${alpha})`,  // Google red
          `rgba(251, 188, 5, ${alpha})`,  // Google yellow
        ];
        return colors[index % colors.length];
      }

      // Format large numbers for display
      function formatNumber(num) {
        if (num >= 1e12) return (num / 1e12).toFixed(2) + 'T';
        if (num >= 1e9) return (num / 1e9).toFixed(2) + 'B';
        if (num >= 1e7) return (num / 1e7).toFixed(2) + 'Cr';
        if (num >= 1e5) return (num / 1e5).toFixed(2) + 'L';
        if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
        return num.toLocaleString();
      }

      // Render chart using Chart.js
      async function renderChart(chartData) {
        if (!chartData) return '';

        const chartId = `chart-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        const { chartType, variableName, labels, datasets, unit, sourceName, sourceUrl } = chartData;

        // Build source attribution HTML
        let sourceHtml = '';
        if (sourceName || sourceUrl) {
          if (sourceUrl) {
            sourceHtml = `<div class="dc-chart-source">Source: <a href="${escapeHtml(sourceUrl)}" target="_blank" rel="noopener">${escapeHtml(sourceName || sourceUrl)}</a></div>`;
          } else {
            sourceHtml = `<div class="dc-chart-source">Source: ${escapeHtml(sourceName)}</div>`;
          }
        }

        // Create chart container HTML
        const containerHtml = `
          <div class="dc-chart-container" id="${chartId}-container">
            <div class="dc-chart-title">${escapeHtml(variableName)}</div>
            <canvas id="${chartId}" style="max-height: 300px;"></canvas>
            <div class="dc-chart-footer">
              ${unit ? `<span class="dc-chart-unit">Unit: ${escapeHtml(unit)}</span>` : ''}
              ${sourceHtml}
            </div>
          </div>
        `;

        return { html: containerHtml, chartId, chartType, labels, datasets, variableName };
      }

      // Inject chart into message after finalization
      async function injectChartIntoMessage(messageEl, chartData) {
        if (!chartData) return;

        try {
          console.log('Injecting chart with data:', chartData);

          await loadChartJs();

          const chartConfig = await renderChart(chartData);
          if (!chartConfig) return;

          const contentEl = messageEl.querySelector('.message-content');
          if (!contentEl) return;

          // Insert chart container - before followup container if it exists
          const followupContainer = contentEl.querySelector('.followup-container');
          if (followupContainer) {
            followupContainer.insertAdjacentHTML('beforebegin', chartConfig.html);
          } else {
            contentEl.insertAdjacentHTML('beforeend', chartConfig.html);
          }
          chatMessages.scrollTop = chatMessages.scrollHeight;

          // Wait for DOM to update
          await new Promise(r => setTimeout(r, 100));

          // Create the chart
          const canvas = document.getElementById(chartConfig.chartId);
          if (!canvas) {
            console.error('Canvas not found:', chartConfig.chartId);
            return;
          }

          const ctx = canvas.getContext('2d');

          new Chart(ctx, {
            type: chartConfig.chartType,
            data: {
              labels: chartConfig.labels,
              datasets: chartConfig.datasets
            },
            options: {
              responsive: true,
              maintainAspectRatio: true,
              spanGaps: false,  // Don't connect lines across null values (for merged datasets)
              plugins: {
                legend: {
                  display: chartConfig.datasets.length > 1,
                  position: 'bottom',
                  labels: {
                    usePointStyle: true,
                    padding: 15
                  }
                },
                title: {
                  display: false
                },
                tooltip: {
                  callbacks: {
                    label: function(context) {
                      const value = context.parsed.y;
                      if (value === null) return null;  // Skip null values in tooltip
                      return `${context.dataset.label}: ${formatNumber(value)}`;
                    }
                  }
                }
              },
              scales: {
                y: {
                  beginAtZero: false,
                  ticks: {
                    callback: function(value) {
                      return formatNumber(value);
                    }
                  }
                }
              },
              interaction: {
                intersect: false,
                mode: 'index'  // Show all datasets at same x-position in tooltip
              }
            }
          });

          console.log('Chart rendered successfully');
          chatMessages.scrollTop = chatMessages.scrollHeight;

        } catch (err) {
          console.error('Failed to inject chart:', err);
          const contentEl = messageEl.querySelector('.message-content');
          if (contentEl) {
            contentEl.insertAdjacentHTML('beforeend',
              `<div class="dc-chart-error">Unable to load visualization: ${err.message}</div>`
            );
          }
        }
      }

      // DOM Elements
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const welcomeMessage = document.getElementById('welcome-message');
      const apiKeyInput = document.getElementById('api-key-input');
      const mcpUrlInput = document.getElementById('mcp-url-input');
      const mcpEnabledCheckbox = document.getElementById('mcp-enabled');
      const kbStoreInput = document.getElementById('kb-store-input');
      const kbEnabledCheckbox = document.getElementById('kb-enabled');
      const saveConfigBtn = document.getElementById('save-config');
      const configStatus = document.getElementById('config-status');

      // New sidebar elements
      const leftSidebar = document.getElementById('left-sidebar');
      const rightSidebar = document.getElementById('right-sidebar');
      const toolCallsContainer = document.getElementById('tool-calls-container');
      const toolsToggle = document.getElementById('tools-toggle');
      const settingsToggle = document.getElementById('settings-toggle');
      const closeSettings = document.getElementById('close-settings');
      const closeTools = document.getElementById('close-tools');
      const mcpStatus = document.getElementById('mcp-status');
      const kbStatus = document.getElementById('kb-status');
      const brandingHeader = document.getElementById('branding-header');

      // Prompt editor elements
      const mcpPromptInput = document.getElementById('mcp-prompt-input');
      const kbPromptInput = document.getElementById('kb-prompt-input');
      const synthesisPromptInput = document.getElementById('synthesis-prompt-input');

      // Toggle prompt section collapse (exposed globally for onclick)
      window.togglePromptSection = function(sectionId) {
        const section = document.getElementById(sectionId);
        if (section) {
          section.classList.toggle('collapsed');
        }
      };

      // Initialize
      function init() {
        // Load saved config
        if (geminiApiKey) apiKeyInput.value = geminiApiKey;
        if (mcpProxyUrl) mcpUrlInput.value = mcpProxyUrl;
        mcpEnabledCheckbox.checked = mcpEnabled;
        if (kbStoreId) kbStoreInput.value = kbStoreId;
        kbEnabledCheckbox.checked = kbEnabled;

        // Populate prompt textareas with current values
        if (mcpPromptInput) mcpPromptInput.value = mcpSystemInstruction;
        if (kbPromptInput) kbPromptInput.value = kbSystemInstruction;
        if (synthesisPromptInput) synthesisPromptInput.value = synthesisSystemInstruction;

        // Event listeners
        saveConfigBtn.addEventListener('click', saveConfig);
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', handleKeyDown);
        chatInput.addEventListener('input', autoResize);

        // Settings toggle tab
        if (settingsToggle) {
          settingsToggle.addEventListener('click', () => {
            rightSidebar.classList.toggle('hidden');
            settingsToggle.classList.toggle('open');
          });
        }

        // Settings close button (secondary)
        if (closeSettings) {
          closeSettings.addEventListener('click', () => {
            rightSidebar.classList.add('hidden');
            settingsToggle.classList.remove('open');
          });
        }

        // Tools toggle tab
        if (toolsToggle) {
          toolsToggle.addEventListener('click', () => {
            leftSidebar.classList.toggle('hidden');
            toolsToggle.classList.toggle('open');
          });
        }

        // Tools close button (secondary)
        if (closeTools) {
          closeTools.addEventListener('click', () => {
            leftSidebar.classList.add('hidden');
            toolsToggle.classList.remove('open');
          });
        }

        // Update status badges
        updateStatusBadges();

        // Suggestion buttons
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.addEventListener('click', () => {
            if (!btn.disabled) {
              chatInput.value = btn.dataset.text;
              sendMessage();
            }
          });
        });

        // Auto-connect if config exists
        if (geminiApiKey) {
          saveConfig();
        }
      }

      // Save configuration and connect
      async function saveConfig() {
        const key = apiKeyInput.value.trim();
        const url = mcpUrlInput.value.trim();
        const enabled = mcpEnabledCheckbox.checked;
        const kbStore = kbStoreInput.value.trim();
        const kbOn = kbEnabledCheckbox.checked;

        if (!key) {
          configStatus.textContent = 'Please enter a Gemini API key';
          configStatus.style.color = 'var(--danger)';
          return;
        }

        geminiApiKey = key;
        mcpProxyUrl = url;
        mcpEnabled = enabled;
        kbStoreId = kbStore;
        kbEnabled = kbOn;

        localStorage.setItem('gemini_api_key', key);
        localStorage.setItem('mcp_proxy_url', url);
        localStorage.setItem('mcp_enabled', enabled.toString());
        localStorage.setItem('kb_store_id', kbStore);
        localStorage.setItem('kb_enabled', kbOn.toString());

        // Save and update system prompts
        const newMcpPrompt = mcpPromptInput?.value?.trim() || mcpSystemInstruction;
        const newKbPrompt = kbPromptInput?.value?.trim() || kbSystemInstruction;
        const newSynthesisPrompt = synthesisPromptInput?.value?.trim() || synthesisSystemInstruction;

        // Update the active prompt variables
        mcpSystemInstruction = newMcpPrompt;
        kbSystemInstruction = newKbPrompt;
        synthesisSystemInstruction = newSynthesisPrompt;

        // Save to localStorage
        localStorage.setItem('mcp_system_prompt', newMcpPrompt);
        localStorage.setItem('kb_system_prompt', newKbPrompt);
        localStorage.setItem('synthesis_system_prompt', newSynthesisPrompt);

        // Console log the updated prompts
        console.group('üìù Prompts Updated (at ' + getCurrentDateTimeIST() + ')');
        console.log('MCP System Prompt (with DateTime):', injectDateTime(mcpSystemInstruction));
        console.log('KB System Prompt (with DateTime):', injectDateTime(kbSystemInstruction));
        console.log('Synthesis Prompt (with DateTime):', injectDateTime(synthesisSystemInstruction));
        console.groupEnd();

        configStatus.textContent = 'Connecting...';
        configStatus.style.color = 'var(--text-muted)';

        // Check MCP connection if enabled
        if (mcpEnabled && url) {
          const connected = await checkMcpConnection();
          mcpConnected = connected;
        } else {
          mcpConnected = false;
        }

        enableChat();
        updateStatusBadges();

        configStatus.innerHTML = 'Connected! <span style="color: var(--success);">Ready to chat.</span>';
      }

      // Check MCP proxy connection and fetch tools
      async function checkMcpConnection() {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/tools`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });

          if (!response.ok) return false;

          const data = await response.json();
          if (data.success && data.tools) {
            mcpTools = data.tools;
            console.log('MCP Tools loaded:', mcpTools.map(t => t.name));
            return true;
          }
          return false;
        } catch (err) {
          console.error('MCP connection error:', err);
          return false;
        }
      }

      // Execute MCP tool call
      async function executeMcpToolCall(name, args) {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/call`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, arguments: args })
          });

          const data = await response.json();

          if (data.success && data.result) {
            // Extract text content from MCP result
            const content = data.result.content;
            if (Array.isArray(content)) {
              return content.map(c => c.text || JSON.stringify(c)).join('\n');
            }
            return JSON.stringify(data.result);
          }

          return JSON.stringify({ error: data.error || 'Unknown error' });
        } catch (err) {
          console.error('MCP tool call error:', err);
          return JSON.stringify({ error: err.message });
        }
      }

      function enableChat() {
        chatInput.disabled = false;
        chatInput.placeholder = mcpConnected
          ? 'Ask about Indian economic data, policies, or government schemes...'
          : 'Ask questions about policies or economic data...';
        sendBtn.disabled = false;
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.disabled = false;
        });
        // Activate branding header when connected
        if (brandingHeader) {
          brandingHeader.classList.remove('inactive');
        }
      }

      // Auto-resize textarea
      function autoResize() {
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';
      }

      function handleKeyDown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      }

      // Update status badges in settings sidebar
      function updateStatusBadges() {
        if (mcpStatus) {
          mcpStatus.textContent = mcpConnected ? 'Connected' : 'Disconnected';
          mcpStatus.className = mcpConnected ? 'status-badge active' : 'status-badge';
        }
        if (kbStatus) {
          kbStatus.textContent = kbEnabled ? 'Active' : 'Inactive';
          kbStatus.className = kbEnabled ? 'status-badge active' : 'status-badge';
        }
      }

      // Clear tool calls from left sidebar
      function clearToolCalls() {
        if (toolCallsContainer) {
          toolCallsContainer.innerHTML = '';
        }
      }

      // Show tool call in LEFT SIDEBAR (not chat)
      function showToolCall(name, args) {
        // Clear empty message if present
        const emptyMsg = toolCallsContainer.querySelector('.tool-calls-empty');
        if (emptyMsg) emptyMsg.remove();

        const toolEl = document.createElement('div');
        toolEl.className = 'tool-call-item loading';
        toolEl.innerHTML = `
          <div class="tool-call-name">
            <span>${escapeHtml(name)}</span>
            <span class="badge">Running</span>
          </div>
          <div class="tool-call-args">${escapeHtml(JSON.stringify(args, null, 2))}</div>
          <div class="tool-call-result"></div>
        `;
        toolCallsContainer.appendChild(toolEl);
        toolCallsContainer.scrollTop = toolCallsContainer.scrollHeight;
        return toolEl;
      }

      function updateToolCallResult(toolEl, result, isError = false, toolName = '') {
        toolEl.classList.remove('loading');
        toolEl.classList.add(isError ? 'error' : 'success');

        // Update badge
        const badge = toolEl.querySelector('.badge');
        if (badge) {
          badge.textContent = isError ? 'Error' : 'Done';
          badge.style.background = isError ? 'var(--danger)' : 'var(--green)';
        }

        const resultEl = toolEl.querySelector('.tool-call-result');
        resultEl.className = `tool-call-result ${isError ? 'error' : 'success'}`;

        // Truncate long results
        let displayResult = result;
        if (result.length > 300) {
          displayResult = result.substring(0, 300) + '... (truncated)';
        }
        resultEl.textContent = displayResult;

        // Analyze for chart data and extract source if this is a get_observations call
        if (!isError && toolName === 'get_observations') {
          try {
            const chartData = analyzeChartData(toolName, result);
            if (chartData) {
              // Accumulate chart data from multiple get_observations calls (for multi-curve charts)
              if (lastChartAnalysis) {
                lastChartAnalysis = mergeChartData(lastChartAnalysis, chartData);
                console.log('Chart data merged (multi-curve):', lastChartAnalysis);
              } else {
                lastChartAnalysis = chartData;
                console.log('Chart data extracted:', chartData);
              }

              // Also store source info for text responses
              if (chartData.sourceName || chartData.sourceUrl) {
                lastDataSource = {
                  name: chartData.sourceName,
                  url: chartData.sourceUrl
                };
                console.log('Data source stored:', lastDataSource);
              }
            }
          } catch (e) {
            console.error('Chart analysis error:', e);
          }
        }

        // Also try to extract source from search_indicators results
        if (!isError && toolName === 'search_indicators') {
          try {
            const data = typeof result === 'string' ? JSON.parse(result) : result;
            // search_indicators doesn't return source directly, but we note it's from Data Commons
            if (data.variables || data.topics) {
              lastDataSource = {
                name: 'Data Commons',
                url: 'https://datacommons.org'
              };
            }
          } catch (e) {
            // Ignore parse errors
          }
        }
      }

      // ============================================================
      // PHASE 1: MCP Tools Query (using gemini-3.0-pro)
      // ============================================================
      async function queryWithMcpTools(userMessage) {
        if (!mcpConnected || mcpTools.length === 0) {
          console.log('MCP not connected or no tools available');
          return { success: false, response: null, error: 'MCP not connected' };
        }

        console.log('=== Starting MCP Query ===');
        console.log(`MCP Tools available: ${mcpTools.map(t => t.name).join(', ')}`);

        try {
          // Build contents with conversation history
          const contents = [];
          // Add conversation history (limit to last 10 turns to avoid token limits)
          const historyLimit = Math.max(0, conversationHistory.length - 20);
          for (let i = historyLimit; i < conversationHistory.length; i++) {
            contents.push(conversationHistory[i]);
          }
          // Add current user message
          contents.push({ role: 'user', parts: [{ text: userMessage }] });

          // Function calling loop
          let maxIterations = 5;
          let iteration = 0;

          // Track which tools have been called to ensure get_observations is called for data queries
          const toolsCalled = new Set();

          while (iteration < maxIterations) {
            iteration++;

            // Build payload
            const payload = {
              contents: contents,
              systemInstruction: { parts: [{ text: injectDateTime(mcpSystemInstruction) }] },
              generationConfig: {
                temperature: 0.7,
                topP: 0.95,
                topK: 40
              }
            };

            // Add tools if MCP is connected
            const dataKeywords = /population|gdp|unemployment|rate|statistics|data|how many|what is the|number of|percent|average|median|income|health|economy|demographics|emissions|climate|crime|education|exports|imports|export|import|trade|dairy|agriculture|production|manufacturing|industry|growth|trend|value|amount|total|cpi|inflation|price|index|expenditure|food|consumer/i;
            const isDataQuery = dataKeywords.test(userMessage);

            // For data queries, keep forcing tool calls until get_observations has been called
            // This ensures the model doesn't stop after just search_indicators
            const needsObservations = isDataQuery && !toolsCalled.has('get_observations');

            if (iteration >= 4) {
              // Don't include tools - force pure text response after many iterations
              console.log(`MCP Iteration ${iteration}: Forcing text response (no tools)`);
            } else {
              // Simplify tool descriptions for Gemini - use longer limit for better understanding
              const simplifiedTools = mcpTools.map(t => ({
                name: t.name,
                description: t.description.length > 2000
                  ? t.description.substring(0, 2000) + '...'
                  : t.description,
                parameters: t.parameters
              }));
              payload.tools = [{ functionDeclarations: simplifiedTools }];

              // Use mode ANY to force tool calls for data queries until get_observations is called
              // This prevents the model from generating text after only calling search_indicators
              const mode = (needsObservations && iteration <= 3) ? 'ANY' : 'AUTO';
              console.log(`MCP Iteration ${iteration}: Using mode ${mode} (needsObservations=${needsObservations}, toolsCalled=${Array.from(toolsCalled).join(',')})`);
              payload.toolConfig = {
                functionCallingConfig: { mode: mode }
              };
            }

            // Call Gemini with MCP_MODEL (2.0-flash)
            console.log('MCP Request payload:', JSON.stringify(payload, null, 2));

            const response = await fetch(
              `${GEMINI_API_BASE}/${MCP_MODEL}:generateContent?key=${geminiApiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              }
            );

            const data = await response.json();
            console.log('MCP Response:', JSON.stringify(data, null, 2));

            if (data.error) {
              throw new Error(data.error.message || 'MCP API request failed');
            }

            const candidates = data.candidates || [];
            if (candidates.length === 0) {
              throw new Error('No response from MCP query');
            }

            const responseParts = candidates[0].content?.parts || [];
            const functionCalls = responseParts.filter(p => p.functionCall);

            if (functionCalls.length > 0 && mcpConnected) {
              // Add model response to conversation
              contents.push({ role: 'model', parts: responseParts });

              // Execute tool calls
              const functionResponses = [];
              for (const part of functionCalls) {
                const fc = part.functionCall;
                console.log(`Executing MCP tool: ${fc.name}`, fc.args);

                // Track that this tool was called
                toolsCalled.add(fc.name);

                // Show tool call in UI
                const toolEl = showToolCall(fc.name, fc.args);

                try {
                  const result = await executeMcpToolCall(fc.name, fc.args);
                  updateToolCallResult(toolEl, result, false, fc.name);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { result: result }
                    }
                  });
                } catch (err) {
                  updateToolCallResult(toolEl, err.message, true, fc.name);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { error: err.message }
                    }
                  });
                }
              }

              // Add function responses
              contents.push({ role: 'user', parts: functionResponses });

            } else {
              // Got text response
              const textParts = responseParts.filter(p => p.text);
              if (textParts.length > 0) {
                const response = textParts.map(p => p.text).join('\n');
                console.log('MCP Query successful');
                return { success: true, response: response, error: null };
              }
              break;
            }
          }

          return { success: false, response: null, error: 'MCP query did not produce response' };

        } catch (err) {
          console.error('MCP Query error:', err);
          return { success: false, response: null, error: err.message };
        }
      }

      // ============================================================
      // PHASE 2: Knowledge Base Query (using gemini-3-flash-preview)
      // ============================================================
      async function queryWithKnowledgeBase(userMessage) {
        if (!kbEnabled || !kbStoreId) {
          console.log('Knowledge base not enabled or no store ID');
          return { success: false, response: null, sources: [], error: 'KB not configured' };
        }

        console.log('=== Starting Knowledge Base Query ===');
        console.log(`KB Store: ${kbStoreId}`);

        try {
          // Build contents with conversation history
          const contents = [];
          // Add conversation history (limit to last 10 turns to avoid token limits)
          const historyLimit = Math.max(0, conversationHistory.length - 20);
          for (let i = historyLimit; i < conversationHistory.length; i++) {
            contents.push(conversationHistory[i]);
          }
          // Add current user message
          contents.push({ role: 'user', parts: [{ text: userMessage }] });

          const payload = {
            contents: contents,
            systemInstruction: { parts: [{ text: injectDateTime(kbSystemInstruction) }] },
            tools: [{
              fileSearch: {
                fileSearchStoreNames: [kbStoreId]
              }
            }],
            generationConfig: {
              temperature: 0.3,
              topP: 0.95,
              topK: 40
            }
          };

          console.log('KB Request payload:', JSON.stringify(payload, null, 2));

          const response = await fetch(
            `${GEMINI_API_BASE}/${KB_MODEL}:generateContent?key=${geminiApiKey}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }
          );

          const data = await response.json();
          console.log('KB Response:', JSON.stringify(data, null, 2));

          if (data.error) {
            throw new Error(data.error.message || 'KB API request failed');
          }

          const candidates = data.candidates || [];
          if (candidates.length === 0) {
            return { success: false, response: null, sources: [], error: 'No KB response' };
          }

          const responseParts = candidates[0].content?.parts || [];
          const textParts = responseParts.filter(p => p.text);
          const responseText = textParts.map(p => p.text).join('\n');

          // Extract sources from grounding metadata
          const sources = [];
          const groundingMetadata = candidates[0].groundingMetadata;
          if (groundingMetadata && groundingMetadata.groundingChunks) {
            groundingMetadata.groundingChunks
              .filter(chunk => chunk.retrievedContext)
              .forEach(chunk => {
                const source = chunk.retrievedContext.title || chunk.retrievedContext.uri;
                if (source && !sources.includes(source)) {
                  sources.push(source);
                }
              });
          }

          console.log('KB Query successful, sources:', sources);
          return { success: true, response: responseText, sources: sources, error: null };

        } catch (err) {
          console.error('KB Query error:', err);
          return { success: false, response: null, sources: [], error: err.message };
        }
      }

      // ============================================================
      // MAIN: Send message - calls BOTH MCP and KB, combines results
      // ============================================================
      async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message || isProcessing || !geminiApiKey) return;

        // Hide welcome message
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }

        // Clear previous tool calls from left sidebar
        clearToolCalls();

        // Reset data source tracking for new query
        lastDataSource = null;

        // Show user message
        addMessage('user', message);

        // Clear input
        chatInput.value = '';
        autoResize();

        // Start processing
        isProcessing = true;
        sendBtn.disabled = true;
        chatInput.disabled = true;
        const typingEl = showTypingIndicator();

        const userMessage = message;

        try {
          console.log('=== Processing Query ===');
          console.log(`User message: ${userMessage}`);
          console.log(`MCP connected: ${mcpConnected}, Tools: ${mcpTools.length}`);
          console.log(`KB enabled: ${kbEnabled}, Store: ${kbStoreId}`);

          // Run BOTH queries in parallel
          const [mcpResult, kbResult] = await Promise.all([
            queryWithMcpTools(userMessage),
            queryWithKnowledgeBase(userMessage)
          ]);

          console.log('MCP Result:', mcpResult);
          console.log('KB Result:', kbResult);

          // Remove typing indicator and create streaming message
          typingEl.remove();
          const streamingMessage = createStreamingMessage();

          // Combine results naturally
          let finalResponse = '';
          let mcpContent = '';
          let kbContent = '';
          let sources = [];

          // Get MCP response content
          if (mcpResult.success && mcpResult.response) {
            mcpContent = mcpResult.response;
          }

          // Get KB response content (if relevant)
          if (kbResult.success && kbResult.response) {
            const noInfoPatterns = /no relevant information|not found in|cannot find|no information available/i;
            if (!noInfoPatterns.test(kbResult.response)) {
              kbContent = kbResult.response;
              if (kbResult.sources && kbResult.sources.length > 0) {
                sources = kbResult.sources;
              }
            }
          }

          // If we have both, use Gemini to synthesize a natural response with streaming
          if (mcpContent && kbContent) {
            try {
              // Build synthesis contents with conversation history for context
              const synthesisContents = [];

              // Build context string
              let contextString = '';
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-10).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 200)}...`
                ).join('\n');
                contextString = `Previous conversation context:\n${recentHistory}\n\n---\n\n`;
              }

              synthesisContents.push({
                role: 'user',
                parts: [{
                  text: `${contextString}User's Question: ${userMessage}

---
**EXPORT-IMPORT DATA (from India Ministry of Commerce)**:
${mcpContent}

---
**POLICY & SCHEME INFORMATION (from Government Documents)**:
${kbContent}

---
Please synthesize this information into a unified response following your formatting guidelines.`
                }]
              });

              const synthesisPayload = {
                contents: synthesisContents,
                systemInstruction: { parts: [{ text: injectDateTime(synthesisSystemInstruction) }] },
                generationConfig: {
                  temperature: 0.3,
                  topP: 0.95
                }
              };

              // Use streaming for synthesis
              finalResponse = await streamGeminiResponse(synthesisPayload, 'gemini-3-flash-preview', streamingMessage);

            } catch (err) {
              console.error('Synthesis streaming error:', err);
              // Fallback: just combine them without streaming
              finalResponse = mcpContent + '\n\n' + kbContent;
              streamingMessage.setText(finalResponse);
            }
          } else if (mcpContent) {
            // Stream a refined response for MCP-only content with conversation context
            try {
              let contextString = '';
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-6).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 150)}...`
                ).join('\n');
                contextString = `Previous conversation context:\n${recentHistory}\n\n---\n\n`;
              }
              const refinePrompt = `${contextString}User's Question: ${userMessage}

---
**STATISTICAL DATA (from India Ministry of Statistics)**:
${mcpContent}

---
Please present this information following your formatting guidelines.`;
              const refinePayload = {
                contents: [{
                  role: 'user',
                  parts: [{ text: refinePrompt }]
                }],
                systemInstruction: { parts: [{ text: injectDateTime(synthesisSystemInstruction) }] },
                generationConfig: { temperature: 0.3, topP: 0.95 }
              };
              finalResponse = await streamGeminiResponse(refinePayload, 'gemini-3-flash-preview', streamingMessage);
            } catch (err) {
              // Fallback to non-streamed
              finalResponse = mcpContent;
              streamingMessage.setText(finalResponse);
            }
          } else if (kbContent) {
            // Refine KB content with synthesis instruction to add follow-up suggestions
            try {
              let contextString = '';
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-6).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 150)}...`
                ).join('\n');
                contextString = `Previous conversation context:\n${recentHistory}\n\n---\n\n`;
              }
              const refinePrompt = `${contextString}User's Question: ${userMessage}

---
**POLICY & SCHEME INFORMATION (from Government Documents)**:
${kbContent}

---
Please present this information following your formatting guidelines.`;
              const refinePayload = {
                contents: [{
                  role: 'user',
                  parts: [{ text: refinePrompt }]
                }],
                systemInstruction: { parts: [{ text: injectDateTime(synthesisSystemInstruction) }] },
                generationConfig: { temperature: 0.3, topP: 0.95 }
              };
              finalResponse = await streamGeminiResponse(refinePayload, 'gemini-3-flash-preview', streamingMessage);
            } catch (err) {
              // Fallback to non-refined KB content
              finalResponse = kbContent;
              streamingMessage.setText(finalResponse);
            }
          } else {
            // Neither worked
            if (mcpResult.error && kbResult.error) {
              finalResponse = 'I was unable to retrieve information for your query. Please try rephrasing your question.';
            } else {
              finalResponse = 'No relevant information found for your query.';
            }
            streamingMessage.setText(finalResponse);
          }

          // Add sources at the end if available
          const allSources = [];

          // Add MCP/Data Commons source
          if (lastDataSource) {
            if (lastDataSource.url) {
              allSources.push(`[${lastDataSource.name || 'Data Commons'}](${lastDataSource.url})`);
            } else if (lastDataSource.name) {
              allSources.push(lastDataSource.name);
            }
          }

          // Add KB sources
          if (sources.length > 0) {
            allSources.push(...sources);
          }

          if (allSources.length > 0) {
            finalResponse += '\n\n**Data Sources:** ' + allSources.join(' | ');
            streamingMessage.setText(finalResponse);
          }

          // Finalize the streaming message (remove cursor)
          streamingMessage.finalize();

          // Inject chart visualization if we have chart data
          if (lastChartAnalysis) {
            console.log('Injecting chart with analysis:', lastChartAnalysis);
            await injectChartIntoMessage(streamingMessage.element, lastChartAnalysis);
            lastChartAnalysis = null;  // Reset for next query
          }

          // Reset data source
          lastDataSource = null;

          // Update conversation history
          conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
          conversationHistory.push({ role: 'model', parts: [{ text: finalResponse }] });

        } catch (err) {
          // Safely remove typing indicator if it still exists
          if (typingEl && typingEl.parentNode) {
            typingEl.remove();
          }
          console.error('Chat error:', err);

          if (err.message.includes('API key')) {
            showError('Invalid API key. Please check your Gemini API key.');
          } else {
            showError(`Error: ${err.message}`);
          }
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          chatInput.disabled = false;
          chatInput.focus();
        }
      }

      // UI helpers
      function addMessage(role, content) {
        const messageEl = document.createElement('div');
        messageEl.className = `message ${role}`;

        const avatar = role === 'user' ? 'You' : 'DA';
        const formattedContent = formatMessage(content);

        messageEl.innerHTML = `
          <div class="message-avatar">${avatar}</div>
          <div class="message-content">${formattedContent}</div>
        `;

        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Create a streaming message bubble that can be updated
      function createStreamingMessage() {
        const messageEl = document.createElement('div');
        messageEl.className = 'message assistant';
        messageEl.innerHTML = `
          <div class="message-avatar">DA</div>
          <div class="message-content"><span class="streaming-cursor">‚ñä</span></div>
        `;
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        const contentEl = messageEl.querySelector('.message-content');
        let currentText = '';

        return {
          element: messageEl,
          // Update with new text chunk
          appendText: (text) => {
            currentText += text;
            contentEl.innerHTML = formatMessage(currentText) + '<span class="streaming-cursor">‚ñä</span>';
            chatMessages.scrollTop = chatMessages.scrollHeight;
          },
          // Finalize the message (remove cursor)
          finalize: () => {
            contentEl.innerHTML = formatMessage(currentText);
            chatMessages.scrollTop = chatMessages.scrollHeight;
          },
          // Get current text
          getText: () => currentText,
          // Set full text
          setText: (text) => {
            currentText = text;
            contentEl.innerHTML = formatMessage(currentText) + '<span class="streaming-cursor">‚ñä</span>';
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
        };
      }

      // Stream content from Gemini API
      async function streamGeminiResponse(payload, model, streamingMessage) {
        const url = `${GEMINI_API_BASE}/${model}:streamGenerateContent?key=${geminiApiKey}&alt=sse`;

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || 'Streaming request failed');
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let fullText = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            // Parse SSE data - each chunk may have multiple "data:" lines
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const jsonStr = line.slice(6);
                if (jsonStr.trim() === '[DONE]') continue;

                try {
                  const data = JSON.parse(jsonStr);
                  const candidates = data.candidates || [];
                  if (candidates.length > 0) {
                    const parts = candidates[0].content?.parts || [];
                    for (const part of parts) {
                      if (part.text) {
                        fullText += part.text;
                        streamingMessage.setText(fullText);
                      }
                    }
                  }
                } catch (e) {
                  // Ignore parse errors for partial JSON
                }
              }
            }
          }

          return fullText;
        } catch (err) {
          console.error('Streaming error:', err);
          throw err;
        }
      }

      function formatMessage(content) {
        // First extract and preserve markdown links before escaping
        const linkPlaceholders = [];
        let processed = content.replace(/\[([^\]]+)\]\((https?:\/\/[^)]+)\)/g, (match, text, url) => {
          const placeholder = `__LINK_${linkPlaceholders.length}__`;
          linkPlaceholders.push({ text, url });
          return placeholder;
        });

        // Extract and preserve suggestion buttons before escaping
        const suggestionPlaceholders = [];
        processed = processed.replace(/\[suggestion:\s*([^\]]+)\]/g, (match, suggestionText) => {
          const placeholder = `__SUGGESTION_${suggestionPlaceholders.length}__`;
          suggestionPlaceholders.push(suggestionText.trim());
          return placeholder;
        });

        // Now escape HTML
        let formatted = escapeHtml(processed);

        // Restore links as proper HTML anchors
        linkPlaceholders.forEach((link, i) => {
          formatted = formatted.replace(`__LINK_${i}__`,
            `<a href="${escapeHtml(link.url)}" target="_blank" rel="noopener" style="color: var(--gov-blue);">${escapeHtml(link.text)}</a>`);
        });

        // Restore suggestions as clickable buttons (temporarily)
        suggestionPlaceholders.forEach((suggestion, i) => {
          formatted = formatted.replace(`__SUGGESTION_${i}__`,
            `<button class="followup-suggestion" data-query="${escapeHtml(suggestion)}">${escapeHtml(suggestion)}</button>`);
        });

        // Apply other markdown formatting
        formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
        formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        formatted = formatted.replace(/\n/g, '<br>');

        // Extract follow-up section and wrap in container (move to end)
        if (suggestionPlaceholders.length > 0) {
          // Find and extract the "Follow up questions:" heading and suggestions
          const followupRegex = /(<strong>Follow up questions:<\/strong>)?(<br>)*(<button class="followup-suggestion"[^>]*>[^<]*<\/button>(<br>)*)+/gi;
          const followupMatch = formatted.match(followupRegex);

          if (followupMatch) {
            // Remove original location
            formatted = formatted.replace(followupRegex, '');
            // Clean up trailing <br> tags
            formatted = formatted.replace(/(<br>)+$/, '');

            // Build clean followup container
            const suggestionsHtml = suggestionPlaceholders.map(s =>
              `<button class="followup-suggestion" data-query="${escapeHtml(s)}">${escapeHtml(s)}</button>`
            ).join('');

            // Add container at end
            formatted += `<div class="followup-container"><div class="followup-heading">Follow up questions:</div>${suggestionsHtml}</div>`;
          }
        }

        return formatted;
      }

      // Handle clicks on follow-up suggestion buttons (event delegation)
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('followup-suggestion')) {
          const query = e.target.dataset.query;
          if (query && !isProcessing) {
            chatInput.value = query;
            sendMessage();
          }
        }
      });

      function showTypingIndicator() {
        const typingEl = document.createElement('div');
        typingEl.className = 'message assistant';
        typingEl.innerHTML = `
          <div class="message-avatar">DA</div>
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        `;
        chatMessages.appendChild(typingEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return typingEl;
      }

      function showError(message) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = message;
        chatMessages.appendChild(errorEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        setTimeout(() => errorEl.remove(), 10000);
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Initialize
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
{% endblock %}
