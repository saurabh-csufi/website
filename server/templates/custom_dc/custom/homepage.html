{#
  Copyright 2023 Google LLC

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
#}

{%- extends BASE_HTML -%}

{% set main_id = 'homepage' %}
{% set page_id = 'page-homepage' %}

{% block head %}
  {{ super() }}
  <style>
    /* Government of India - MSME Portal Styles */
    :root {
      --gov-blue: #003366;
      --gov-blue-light: #004080;
      --gov-blue-dark: #001a33;
      --saffron: #FF9933;
      --white: #FFFFFF;
      --green: #138808;
      --chakra-blue: #000080;
      --text-dark: #1a1a2e;
      --text-muted: #5f6368;
      --bg-light: #f5f7fa;
      --border-color: #dee2e6;
      --success: #28a745;
      --warning: #ffc107;
      --danger: #dc3545;
    }

    * {
      box-sizing: border-box;
    }

    /* Full Page Layout */
    #homepage {
      display: flex;
      flex-direction: column;
      min-height: calc(100vh - 70px);
      padding: 0;
    }

    /* Main Chat Container */
    .main-container {
      display: flex;
      flex-direction: column;
      flex: 1;
      max-width: 1200px;
      width: 100%;
      margin: 0 auto;
      padding: 16px 20px 0 20px;
    }

    /* Settings Panel */
    .settings-panel {
      background: white;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      margin-bottom: 16px;
      overflow: hidden;
    }

    .settings-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--gov-blue);
      color: white;
      cursor: pointer;
    }

    .settings-header h3 {
      margin: 0;
      font-size: 0.9rem;
      font-weight: 500;
    }

    .settings-toggle {
      background: none;
      border: none;
      color: white;
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0;
      line-height: 1;
    }

    .settings-content {
      padding: 16px;
      border-top: 1px solid var(--border-color);
    }

    .settings-content.hidden {
      display: none;
    }

    .config-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
    }

    .config-item {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .config-item label {
      font-weight: 600;
      font-size: 0.8rem;
      color: var(--gov-blue);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .config-item input[type="text"] {
      padding: 10px 12px;
      border: 1px solid var(--border-color);
      border-radius: 4px;
      font-size: 0.9rem;
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
    }

    .config-item input[type="text"]:focus {
      outline: none;
      border-color: var(--gov-blue);
      box-shadow: 0 0 0 3px rgba(0, 51, 102, 0.1);
    }

    .config-row-inline {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .toggle-switch input[type="checkbox"] {
      width: 18px;
      height: 18px;
      accent-color: var(--gov-blue);
    }

    .toggle-switch label {
      font-size: 0.85rem;
      color: var(--text-dark);
      text-transform: none;
      font-weight: 500;
    }

    .config-actions {
      display: flex;
      gap: 12px;
      align-items: center;
      margin-top: 16px;
      padding-top: 16px;
      border-top: 1px solid var(--border-color);
    }

    .btn-primary {
      background: var(--gov-blue);
      color: white;
      border: none;
      padding: 10px 24px;
      border-radius: 4px;
      font-weight: 600;
      cursor: pointer;
      font-size: 0.9rem;
      transition: background 0.2s;
    }

    .btn-primary:hover {
      background: var(--gov-blue-light);
    }

    .config-help {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    .config-help a {
      color: var(--gov-blue);
      text-decoration: none;
    }

    .config-help a:hover {
      text-decoration: underline;
    }

    .config-help code {
      background: #e9ecef;
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 0.75rem;
    }

    /* Chat Area */
    .chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: white;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      overflow: hidden;
      min-height: 400px;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      background: linear-gradient(180deg, #f8f9fa 0%, #ffffff 100%);
      min-height: 300px;
    }

    .message {
      margin-bottom: 20px;
      display: flex;
      gap: 12px;
    }

    .message.user {
      flex-direction: row-reverse;
    }

    .message-avatar {
      width: 40px;
      height: 40px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .message.user .message-avatar {
      background: var(--gov-blue);
      color: white;
    }

    .message.assistant .message-avatar {
      background: linear-gradient(135deg, var(--saffron) 0%, var(--green) 100%);
      color: white;
    }

    .message-content {
      max-width: 70%;
      padding: 14px 18px;
      border-radius: 12px;
      line-height: 1.6;
      font-size: 0.95rem;
    }

    .message.user .message-content {
      background: var(--gov-blue);
      color: white;
      border-bottom-right-radius: 4px;
    }

    .message.assistant .message-content {
      background: white;
      color: var(--text-dark);
      border-bottom-left-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
      border: 1px solid #e9ecef;
    }

    .message-content p {
      margin: 0 0 10px 0;
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content pre {
      background: #1e1e1e;
      color: #d4d4d4;
      padding: 14px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 10px 0;
      font-size: 0.85rem;
    }

    .message-content code {
      font-family: 'Monaco', 'Menlo', 'Consolas', monospace;
      font-size: 0.9em;
    }

    .message.user .message-content code {
      background: rgba(255,255,255,0.2);
      padding: 2px 6px;
      border-radius: 3px;
    }

    .message.assistant .message-content code:not(pre code) {
      background: #f1f3f4;
      padding: 2px 6px;
      border-radius: 3px;
      color: var(--gov-blue);
    }

    /* Tool Call Indicator */
    .tool-call-indicator {
      background: linear-gradient(135deg, #e8f4fd 0%, #f0f7ff 100%);
      border: 1px solid #b3d7f5;
      border-left: 4px solid var(--gov-blue);
      border-radius: 6px;
      padding: 12px 16px;
      margin: 12px 0;
      font-size: 0.85rem;
    }

    .tool-call-indicator.loading {
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .tool-call-header {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 600;
      color: var(--gov-blue);
      margin-bottom: 8px;
    }

    .tool-call-args {
      color: var(--text-muted);
      font-family: monospace;
      font-size: 0.8rem;
      background: white;
      padding: 8px 12px;
      border-radius: 4px;
      word-break: break-all;
      border: 1px solid #e9ecef;
    }

    .tool-call-result {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid #b3d7f5;
      color: var(--success);
      font-size: 0.8rem;
    }

    .tool-call-result.error {
      color: var(--danger);
    }

    /* Welcome Message */
    .welcome-message {
      text-align: center;
      padding: 60px 40px;
    }

    .welcome-icon {
      width: 80px;
      height: 80px;
      background: linear-gradient(135deg, var(--saffron) 0%, var(--green) 100%);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto 24px;
      font-size: 36px;
    }

    .welcome-message h2 {
      color: var(--gov-blue);
      margin: 0 0 12px 0;
      font-size: 1.5rem;
      font-weight: 600;
    }

    .welcome-message p {
      color: var(--text-muted);
      margin: 0 0 28px 0;
      font-size: 1rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .welcome-message .suggestions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }

    .welcome-message .suggestion {
      background: white;
      border: 2px solid var(--border-color);
      border-radius: 24px;
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 0.9rem;
      color: var(--text-dark);
    }

    .welcome-message .suggestion:hover:not(:disabled) {
      border-color: var(--gov-blue);
      background: #f0f7ff;
      color: var(--gov-blue);
    }

    .welcome-message .suggestion:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Chat Input Area */
    .chat-input-area {
      background: white;
      border-top: 1px solid var(--border-color);
      padding: 16px 24px;
    }

    .chat-input-row {
      display: flex;
      gap: 12px;
      align-items: flex-end;
    }

    .chat-input-wrapper {
      flex: 1;
    }

    #chat-input {
      width: 100%;
      border: 2px solid var(--border-color);
      border-radius: 24px;
      padding: 14px 22px;
      font-size: 1rem;
      resize: none;
      min-height: 52px;
      max-height: 150px;
      line-height: 1.5;
      outline: none;
      transition: border-color 0.2s, box-shadow 0.2s;
      font-family: inherit;
    }

    #chat-input:focus {
      border-color: var(--gov-blue);
      box-shadow: 0 0 0 4px rgba(0, 51, 102, 0.1);
    }

    #chat-input:disabled {
      background: #f5f5f5;
      cursor: not-allowed;
    }

    #send-btn {
      background: var(--gov-blue);
      color: white;
      border: none;
      border-radius: 50%;
      width: 52px;
      height: 52px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    #send-btn:hover:not(:disabled) {
      background: var(--gov-blue-light);
      transform: scale(1.05);
    }

    #send-btn:disabled {
      background: #adb5bd;
      cursor: not-allowed;
    }

    #send-btn svg {
      width: 22px;
      height: 22px;
    }

    /* Typing Indicator */
    .typing-indicator {
      display: flex;
      gap: 5px;
      padding: 14px 18px;
    }

    .typing-indicator span {
      width: 10px;
      height: 10px;
      background: var(--gov-blue);
      border-radius: 50%;
      animation: typing 1.4s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(1) { animation-delay: 0s; }
    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typing {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-10px); opacity: 1; }
    }

    /* Streaming cursor animation */
    .streaming-cursor {
      display: inline-block;
      animation: blink 0.8s infinite;
      color: var(--gov-blue);
      font-weight: normal;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* Error Message */
    .error-message {
      background: #fdf2f2;
      color: var(--danger);
      padding: 14px 18px;
      border-radius: 8px;
      margin-bottom: 16px;
      border: 1px solid #fecaca;
      border-left: 4px solid var(--danger);
    }

    /* Google Data Commons Footer */
    .google-footer {
      background: #ffffff;
      border-top: 1px solid var(--border-color);
      padding: 16px 24px;
      text-align: center;
      margin-top: auto;
    }

    .google-footer-content {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .google-logo {
      display: inline-flex;
      align-items: center;
      font-weight: 500;
      letter-spacing: -0.5px;
    }

    .google-logo .g-blue { color: #4285F4; }
    .google-logo .g-red { color: #EA4335; }
    .google-logo .g-yellow { color: #FBBC05; }
    .google-logo .g-green { color: #34A853; }

    .google-footer a {
      color: #4285F4;
      text-decoration: none;
      font-weight: 500;
    }

    .google-footer a:hover {
      text-decoration: underline;
    }

    /* Responsive */
    @media (max-width: 992px) {
      .main-container {
        padding: 12px 16px 0 16px;
      }

      .chat-area {
        min-height: 350px;
      }

      .message-content {
        max-width: 80%;
      }
    }

    @media (max-width: 768px) {
      #homepage {
        min-height: calc(100vh - 60px);
      }

      .main-container {
        padding: 10px 12px 0 12px;
      }

      .settings-panel {
        margin-bottom: 12px;
      }

      .settings-header {
        padding: 10px 14px;
      }

      .settings-content {
        padding: 12px;
      }

      .config-grid {
        grid-template-columns: 1fr;
        gap: 12px;
      }

      .config-row-inline {
        flex-wrap: wrap;
      }

      .chat-area {
        min-height: 300px;
        border-radius: 6px;
      }

      .chat-messages {
        padding: 16px;
        min-height: 250px;
      }

      .message-content {
        max-width: 88%;
        padding: 12px 14px;
        font-size: 0.9rem;
      }

      .message-avatar {
        width: 32px;
        height: 32px;
        font-size: 12px;
      }

      .welcome-message {
        padding: 30px 16px;
      }

      .welcome-message h2 {
        font-size: 1.2rem;
      }

      .welcome-message p {
        font-size: 0.9rem;
      }

      .welcome-message .suggestions {
        flex-direction: column;
        align-items: stretch;
      }

      .welcome-message .suggestion {
        text-align: left;
        font-size: 0.85rem;
        padding: 12px 16px;
      }

      .chat-input-area {
        padding: 12px 16px;
      }

      #chat-input {
        padding: 12px 18px;
        font-size: 0.95rem;
        min-height: 46px;
      }

      #send-btn {
        width: 46px;
        height: 46px;
      }

      .google-footer {
        padding: 12px 16px;
      }

      .google-footer-content {
        font-size: 0.8rem;
        flex-wrap: wrap;
      }
    }

    @media (max-width: 480px) {
      .welcome-icon {
        width: 60px;
        height: 60px;
        font-size: 28px;
      }

      .tool-call-indicator {
        padding: 10px 12px;
        font-size: 0.8rem;
      }

      .tool-call-args {
        font-size: 0.75rem;
        padding: 6px 10px;
      }
    }
  </style>
{% endblock %}

{% block content %}
  <!-- Main Container -->
  <div class="main-container">
    <!-- Settings Panel -->
    <div class="settings-panel">
      <div class="settings-header" id="settings-toggle">
        <h3>Configuration Settings</h3>
        <button class="settings-toggle" id="toggle-icon">-</button>
      </div>
      <div class="settings-content" id="settings-content">
        <div class="config-grid">
          <div class="config-item">
            <label for="api-key-input">Gemini API Key</label>
            <input type="text" id="api-key-input" placeholder="Enter your Gemini API key">
          </div>
          <div class="config-item">
            <label for="mcp-url-input">MCP Proxy URL</label>
            <div class="config-row-inline">
              <input type="text" id="mcp-url-input" placeholder="http://localhost:5001" value="http://localhost:5001" style="flex:1;">
              <div class="toggle-switch">
                <input type="checkbox" id="mcp-enabled" checked>
                <label for="mcp-enabled">Enable</label>
              </div>
            </div>
          </div>
          <div class="config-item">
            <label for="kb-store-input">Knowledge Base Store</label>
            <div class="config-row-inline">
              <input type="text" id="kb-store-input" placeholder="fileSearchStores/your-store-id" value="fileSearchStores/msmepolicies-8pibj9lwmrws" style="flex:1;">
              <div class="toggle-switch">
                <input type="checkbox" id="kb-enabled" checked>
                <label for="kb-enabled">Enable</label>
              </div>
            </div>
          </div>
        </div>
        <div class="config-actions">
          <button class="btn-primary" id="save-config">Save & Connect</button>
          <span class="config-help" id="config-status">
            Get API key from <a href="https://aistudio.google.com/apikey" target="_blank">Google AI Studio</a>.
            Run MCP: <code>python additional_features/mcp_proxy_only.py</code>
          </span>
        </div>
      </div>
    </div>

    <!-- Chat Area -->
    <div class="chat-area">
      <div class="chat-messages" id="chat-messages">
        <div class="welcome-message" id="welcome-message">
          <div class="welcome-icon">VS</div>
          <h2>VYAPAR SAH<span style="color: var(--saffron);">(AI)</span></h2>
          <p>Your Intelligent Business Companion | आपका बुद्धिमान व्यापार सहायक</p>
          <div class="suggestions">
            <button class="suggestion" data-text="What are the key MSME policies and schemes available in India?" disabled>What are the key MSME policies and schemes available in India?</button>
            <button class="suggestion" data-text="What is the current GDP growth rate of India?" disabled>What is the current GDP growth rate of India?</button>
            <button class="suggestion" data-text="What export incentives and subsidies are available for small businesses?" disabled>What export incentives and subsidies are available for small businesses?</button>
            <!-- <button class="suggestion" data-text="How can MSMEs register under the Udyam portal?" disabled>How can MSMEs register under the Udyam portal?</button> -->
          </div>
        </div>
      </div>

      <div class="chat-input-area">
        <div class="chat-input-row">
          <div class="chat-input-wrapper">
            <textarea
              id="chat-input"
              placeholder="Configure settings to start chatting..."
              rows="1"
              disabled
            ></textarea>
          </div>
          <button id="send-btn" title="Send message" disabled>
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z"/>
            </svg>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Google Data Commons Footer -->
  <footer class="google-footer">
    <div class="google-footer-content">
      <span>Powered by</span>
      <span class="google-logo">
        <span class="g-blue">G</span><span class="g-red">o</span><span class="g-yellow">o</span><span class="g-blue">g</span><span class="g-green">l</span><span class="g-red">e</span>
      </span>
      <a href="https://datacommons.org" target="_blank" rel="noopener">Data Commons</a>
    </div>
  </footer>

  <script>
    (function() {
      // Configuration
      const GEMINI_API_BASE = 'https://generativelanguage.googleapis.com/v1beta/models';

      // State
      let geminiApiKey = localStorage.getItem('gemini_api_key') || '';
      let mcpProxyUrl = localStorage.getItem('mcp_proxy_url') || 'http://localhost:5001';
      let mcpEnabled = localStorage.getItem('mcp_enabled') !== 'false';
      let kbStoreId = localStorage.getItem('kb_store_id') || 'fileSearchStores/msmepolicies-8pibj9lwmrws';
      let kbEnabled = localStorage.getItem('kb_enabled') !== 'false';
      let mcpTools = [];
      let mcpConnected = false;
      let conversationHistory = [];
      let isProcessing = false;

      // DOM Elements
      const chatMessages = document.getElementById('chat-messages');
      const chatInput = document.getElementById('chat-input');
      const sendBtn = document.getElementById('send-btn');
      const welcomeMessage = document.getElementById('welcome-message');
      const settingsContent = document.getElementById('settings-content');
      const settingsToggle = document.getElementById('settings-toggle');
      const toggleIcon = document.getElementById('toggle-icon');
      const apiKeyInput = document.getElementById('api-key-input');
      const mcpUrlInput = document.getElementById('mcp-url-input');
      const mcpEnabledCheckbox = document.getElementById('mcp-enabled');
      const kbStoreInput = document.getElementById('kb-store-input');
      const kbEnabledCheckbox = document.getElementById('kb-enabled');
      const saveConfigBtn = document.getElementById('save-config');
      const configStatus = document.getElementById('config-status');

      // Models - use different models for different purposes
      const MCP_MODEL = 'gemini-2.0-flash';  // For MCP function calling (proven to work)
      const KB_MODEL = 'gemini-2.5-flash';   // For file search (requires 2.5)

      // System instructions
      const mcpSystemInstruction = `You are a Data Commons AI assistant with access to real-time statistical data tools.

CRITICAL: When users ask about ANY statistics, data, numbers, demographics, economics, health, environment, population, GDP, unemployment, or similar quantitative information:
1. You MUST use the available tools to fetch real data - NEVER make up numbers or provide code examples
2. First call search_indicators to find the right variable DCID for the query
3. Then call get_observations with the variable and place DCIDs to get actual data
4. Present the data clearly with the actual numbers and dates from the tool response

Tool workflow for data queries:
- Step 1: search_indicators(query="population", places=["California, USA"]) -> get variable DCID
- Step 2: get_observations(variable_dcid="...", place_dcid="...") -> get actual data
- Step 3: Present the numbers from the response

DO NOT generate Python code or tell users how to query - use the tools yourself and return the actual data.
Be concise but comprehensive. Cite "Data Commons" as the source when presenting data.`;

      const kbSystemInstruction = `You are a helpful assistant that answers questions based on the uploaded policy documents.
Always cite which document your information comes from.
If the answer is not found in the documents, say "No relevant information found in knowledge base."
Be concise and factual.`;

      // Initialize
      function init() {
        // Load saved config
        if (geminiApiKey) apiKeyInput.value = geminiApiKey;
        if (mcpProxyUrl) mcpUrlInput.value = mcpProxyUrl;
        mcpEnabledCheckbox.checked = mcpEnabled;
        if (kbStoreId) kbStoreInput.value = kbStoreId;
        kbEnabledCheckbox.checked = kbEnabled;

        // Event listeners
        saveConfigBtn.addEventListener('click', saveConfig);
        settingsToggle.addEventListener('click', () => {
          const isHidden = settingsContent.classList.toggle('hidden');
          toggleIcon.textContent = isHidden ? '+' : '-';
        });
        sendBtn.addEventListener('click', sendMessage);
        chatInput.addEventListener('keydown', handleKeyDown);
        chatInput.addEventListener('input', autoResize);

        // Suggestion buttons
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.addEventListener('click', () => {
            if (!btn.disabled) {
              chatInput.value = btn.dataset.text;
              sendMessage();
            }
          });
        });

        // Auto-connect if config exists
        if (geminiApiKey) {
          saveConfig();
        }
      }

      // Save configuration and connect
      async function saveConfig() {
        const key = apiKeyInput.value.trim();
        const url = mcpUrlInput.value.trim();
        const enabled = mcpEnabledCheckbox.checked;
        const kbStore = kbStoreInput.value.trim();
        const kbOn = kbEnabledCheckbox.checked;

        if (!key) {
          configStatus.textContent = 'Please enter a Gemini API key';
          configStatus.style.color = 'var(--danger)';
          return;
        }

        geminiApiKey = key;
        mcpProxyUrl = url;
        mcpEnabled = enabled;
        kbStoreId = kbStore;
        kbEnabled = kbOn;

        localStorage.setItem('gemini_api_key', key);
        localStorage.setItem('mcp_proxy_url', url);
        localStorage.setItem('mcp_enabled', enabled.toString());
        localStorage.setItem('kb_store_id', kbStore);
        localStorage.setItem('kb_enabled', kbOn.toString());

        configStatus.textContent = 'Connecting...';
        configStatus.style.color = 'var(--text-muted)';

        // Check MCP connection if enabled
        if (mcpEnabled && url) {
          const connected = await checkMcpConnection();
          mcpConnected = connected;
        } else {
          mcpConnected = false;
        }

        enableChat();

        configStatus.innerHTML = 'Connected! <span style="color: var(--success);">Ready to chat.</span>';
      }

      // Check MCP proxy connection and fetch tools
      async function checkMcpConnection() {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/tools`, {
            method: 'GET',
            headers: { 'Accept': 'application/json' }
          });

          if (!response.ok) return false;

          const data = await response.json();
          if (data.success && data.tools) {
            mcpTools = data.tools;
            console.log('MCP Tools loaded:', mcpTools.map(t => t.name));
            return true;
          }
          return false;
        } catch (err) {
          console.error('MCP connection error:', err);
          return false;
        }
      }

      // Execute MCP tool call
      async function executeMcpToolCall(name, args) {
        try {
          const response = await fetch(`${mcpProxyUrl}/api/call`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name, arguments: args })
          });

          const data = await response.json();

          if (data.success && data.result) {
            // Extract text content from MCP result
            const content = data.result.content;
            if (Array.isArray(content)) {
              return content.map(c => c.text || JSON.stringify(c)).join('\n');
            }
            return JSON.stringify(data.result);
          }

          return JSON.stringify({ error: data.error || 'Unknown error' });
        } catch (err) {
          console.error('MCP tool call error:', err);
          return JSON.stringify({ error: err.message });
        }
      }

      function enableChat() {
        chatInput.disabled = false;
        chatInput.placeholder = mcpConnected
          ? 'Ask about MSME policies, statistics, or government schemes...'
          : 'Ask questions about policies or upload documents...';
        sendBtn.disabled = false;
        document.querySelectorAll('.suggestion').forEach(btn => {
          btn.disabled = false;
        });
      }

      // Auto-resize textarea
      function autoResize() {
        chatInput.style.height = 'auto';
        chatInput.style.height = Math.min(chatInput.scrollHeight, 150) + 'px';
      }

      function handleKeyDown(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          sendMessage();
        }
      }

      // Show tool call in UI
      function showToolCall(name, args) {
        const toolEl = document.createElement('div');
        toolEl.className = 'tool-call-indicator loading';
        toolEl.innerHTML = `
          <div class="tool-call-header">
            <span>[Tool]</span>
            <span>${escapeHtml(name)}</span>
          </div>
          <div class="tool-call-args">${escapeHtml(JSON.stringify(args, null, 2))}</div>
          <div class="tool-call-result"></div>
        `;
        chatMessages.appendChild(toolEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return toolEl;
      }

      function updateToolCallResult(toolEl, result, isError = false) {
        toolEl.classList.remove('loading');
        const resultEl = toolEl.querySelector('.tool-call-result');
        resultEl.className = `tool-call-result${isError ? ' error' : ''}`;

        // Truncate long results
        let displayResult = result;
        if (result.length > 500) {
          displayResult = result.substring(0, 500) + '... (truncated)';
        }
        resultEl.textContent = displayResult;
      }

      // ============================================================
      // PHASE 1: MCP Tools Query (using gemini-2.0-flash)
      // ============================================================
      async function queryWithMcpTools(userMessage) {
        if (!mcpConnected || mcpTools.length === 0) {
          console.log('MCP not connected or no tools available');
          return { success: false, response: null, error: 'MCP not connected' };
        }

        console.log('=== Starting MCP Query ===');
        console.log(`MCP Tools available: ${mcpTools.map(t => t.name).join(', ')}`);

        try {
          // Build contents with conversation history
          const contents = [];
          // Add conversation history (limit to last 10 turns to avoid token limits)
          const historyLimit = Math.max(0, conversationHistory.length - 20);
          for (let i = historyLimit; i < conversationHistory.length; i++) {
            contents.push(conversationHistory[i]);
          }
          // Add current user message
          contents.push({ role: 'user', parts: [{ text: userMessage }] });

          // Function calling loop
          let maxIterations = 5;
          let iteration = 0;

          while (iteration < maxIterations) {
            iteration++;

            // Build payload
            const payload = {
              contents: contents,
              systemInstruction: { parts: [{ text: mcpSystemInstruction }] },
              generationConfig: {
                temperature: 0.7,
                topP: 0.95,
                topK: 40
              }
            };

            // Add tools if MCP is connected
            const dataKeywords = /population|gdp|unemployment|rate|statistics|data|how many|what is the|number of|percent|average|median|income|health|economy|demographics|emissions|climate|crime|education/i;
            const isDataQuery = dataKeywords.test(userMessage);

            if (iteration >= 3) {
              // Don't include tools - force pure text response
              console.log(`MCP Iteration ${iteration}: Forcing text response (no tools)`);
            } else {
              // Simplify tool descriptions for Gemini
              const simplifiedTools = mcpTools.map(t => ({
                name: t.name,
                description: t.description.length > 500
                  ? t.description.substring(0, 500) + '...'
                  : t.description,
                parameters: t.parameters
              }));
              payload.tools = [{ functionDeclarations: simplifiedTools }];

              const mode = (iteration === 1 && isDataQuery) ? 'ANY' : 'AUTO';
              console.log(`MCP Iteration ${iteration}: Using mode ${mode}`);
              payload.toolConfig = {
                functionCallingConfig: { mode: mode }
              };
            }

            // Call Gemini with MCP_MODEL (2.0-flash)
            console.log('MCP Request payload:', JSON.stringify(payload, null, 2));

            const response = await fetch(
              `${GEMINI_API_BASE}/${MCP_MODEL}:generateContent?key=${geminiApiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              }
            );

            const data = await response.json();
            console.log('MCP Response:', JSON.stringify(data, null, 2));

            if (data.error) {
              throw new Error(data.error.message || 'MCP API request failed');
            }

            const candidates = data.candidates || [];
            if (candidates.length === 0) {
              throw new Error('No response from MCP query');
            }

            const responseParts = candidates[0].content?.parts || [];
            const functionCalls = responseParts.filter(p => p.functionCall);

            if (functionCalls.length > 0 && mcpConnected) {
              // Add model response to conversation
              contents.push({ role: 'model', parts: responseParts });

              // Execute tool calls
              const functionResponses = [];
              for (const part of functionCalls) {
                const fc = part.functionCall;
                console.log(`Executing MCP tool: ${fc.name}`, fc.args);

                // Show tool call in UI
                const toolEl = showToolCall(fc.name, fc.args);

                try {
                  const result = await executeMcpToolCall(fc.name, fc.args);
                  updateToolCallResult(toolEl, result, false);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { result: result }
                    }
                  });
                } catch (err) {
                  updateToolCallResult(toolEl, err.message, true);
                  functionResponses.push({
                    functionResponse: {
                      name: fc.name,
                      response: { error: err.message }
                    }
                  });
                }
              }

              // Add function responses
              contents.push({ role: 'user', parts: functionResponses });

            } else {
              // Got text response
              const textParts = responseParts.filter(p => p.text);
              if (textParts.length > 0) {
                const response = textParts.map(p => p.text).join('\n');
                console.log('MCP Query successful');
                return { success: true, response: response, error: null };
              }
              break;
            }
          }

          return { success: false, response: null, error: 'MCP query did not produce response' };

        } catch (err) {
          console.error('MCP Query error:', err);
          return { success: false, response: null, error: err.message };
        }
      }

      // ============================================================
      // PHASE 2: Knowledge Base Query (using gemini-2.5-flash)
      // ============================================================
      async function queryWithKnowledgeBase(userMessage) {
        if (!kbEnabled || !kbStoreId) {
          console.log('Knowledge base not enabled or no store ID');
          return { success: false, response: null, sources: [], error: 'KB not configured' };
        }

        console.log('=== Starting Knowledge Base Query ===');
        console.log(`KB Store: ${kbStoreId}`);

        try {
          // Build contents with conversation history
          const contents = [];
          // Add conversation history (limit to last 10 turns to avoid token limits)
          const historyLimit = Math.max(0, conversationHistory.length - 20);
          for (let i = historyLimit; i < conversationHistory.length; i++) {
            contents.push(conversationHistory[i]);
          }
          // Add current user message
          contents.push({ role: 'user', parts: [{ text: userMessage }] });

          const payload = {
            contents: contents,
            systemInstruction: { parts: [{ text: kbSystemInstruction }] },
            tools: [{
              fileSearch: {
                fileSearchStoreNames: [kbStoreId]
              }
            }],
            generationConfig: {
              temperature: 0.3,
              topP: 0.95,
              topK: 40
            }
          };

          console.log('KB Request payload:', JSON.stringify(payload, null, 2));

          const response = await fetch(
            `${GEMINI_API_BASE}/${KB_MODEL}:generateContent?key=${geminiApiKey}`,
            {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(payload)
            }
          );

          const data = await response.json();
          console.log('KB Response:', JSON.stringify(data, null, 2));

          if (data.error) {
            throw new Error(data.error.message || 'KB API request failed');
          }

          const candidates = data.candidates || [];
          if (candidates.length === 0) {
            return { success: false, response: null, sources: [], error: 'No KB response' };
          }

          const responseParts = candidates[0].content?.parts || [];
          const textParts = responseParts.filter(p => p.text);
          const responseText = textParts.map(p => p.text).join('\n');

          // Extract sources from grounding metadata
          const sources = [];
          const groundingMetadata = candidates[0].groundingMetadata;
          if (groundingMetadata && groundingMetadata.groundingChunks) {
            groundingMetadata.groundingChunks
              .filter(chunk => chunk.retrievedContext)
              .forEach(chunk => {
                const source = chunk.retrievedContext.title || chunk.retrievedContext.uri;
                if (source && !sources.includes(source)) {
                  sources.push(source);
                }
              });
          }

          console.log('KB Query successful, sources:', sources);
          return { success: true, response: responseText, sources: sources, error: null };

        } catch (err) {
          console.error('KB Query error:', err);
          return { success: false, response: null, sources: [], error: err.message };
        }
      }

      // ============================================================
      // MAIN: Send message - calls BOTH MCP and KB, combines results
      // ============================================================
      async function sendMessage() {
        const message = chatInput.value.trim();
        if (!message || isProcessing || !geminiApiKey) return;

        // Hide welcome message
        if (welcomeMessage) {
          welcomeMessage.style.display = 'none';
        }

        // Show user message
        addMessage('user', message);

        // Clear input
        chatInput.value = '';
        autoResize();

        // Start processing
        isProcessing = true;
        sendBtn.disabled = true;
        chatInput.disabled = true;
        const typingEl = showTypingIndicator();

        const userMessage = message;

        try {
          console.log('=== Processing Query ===');
          console.log(`User message: ${userMessage}`);
          console.log(`MCP connected: ${mcpConnected}, Tools: ${mcpTools.length}`);
          console.log(`KB enabled: ${kbEnabled}, Store: ${kbStoreId}`);

          // Run BOTH queries in parallel
          const [mcpResult, kbResult] = await Promise.all([
            queryWithMcpTools(userMessage),
            queryWithKnowledgeBase(userMessage)
          ]);

          console.log('MCP Result:', mcpResult);
          console.log('KB Result:', kbResult);

          // Remove typing indicator and create streaming message
          typingEl.remove();
          const streamingMessage = createStreamingMessage();

          // Combine results naturally
          let finalResponse = '';
          let mcpContent = '';
          let kbContent = '';
          let sources = [];

          // Get MCP response content
          if (mcpResult.success && mcpResult.response) {
            mcpContent = mcpResult.response;
          }

          // Get KB response content (if relevant)
          if (kbResult.success && kbResult.response) {
            const noInfoPatterns = /no relevant information|not found in|cannot find|no information available/i;
            if (!noInfoPatterns.test(kbResult.response)) {
              kbContent = kbResult.response;
              if (kbResult.sources && kbResult.sources.length > 0) {
                sources = kbResult.sources;
              }
            }
          }

          // If we have both, use Gemini to synthesize a natural response with streaming
          if (mcpContent && kbContent) {
            try {
              // Build synthesis contents with conversation history for context
              const synthesisContents = [];
              // Add conversation history summary for context
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-10).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 200)}...`
                ).join('\n');
                synthesisContents.push({
                  role: 'user',
                  parts: [{
                    text: `Previous conversation context:\n${recentHistory}\n\n---\n\nNow, combine these two pieces of information into a single, coherent, natural response to the user's latest question. Do not use labels like "From Data Commons" or "From Policy Documents". Just provide a unified helpful answer.

User's latest question: ${userMessage}

Statistical/Data information:
${mcpContent}

Policy/Document information:
${kbContent}

Provide a natural, combined response that integrates both pieces of information smoothly:`
                  }]
                });
              } else {
                synthesisContents.push({
                  role: 'user',
                  parts: [{
                    text: `You are an assistant helping with MSME and policy queries. Combine these two pieces of information into a single, coherent, natural response. Do not use labels like "From Data Commons" or "From Policy Documents". Just provide a unified helpful answer.

User's question: ${userMessage}

Statistical/Data information:
${mcpContent}

Policy/Document information:
${kbContent}

Provide a natural, combined response that integrates both pieces of information smoothly:`
                  }]
                });
              }

              const synthesisPayload = {
                contents: synthesisContents,
                generationConfig: {
                  temperature: 0.3,
                  topP: 0.95
                }
              };

              // Use streaming for synthesis
              finalResponse = await streamGeminiResponse(synthesisPayload, 'gemini-2.0-flash', streamingMessage);

            } catch (err) {
              console.error('Synthesis streaming error:', err);
              // Fallback: just combine them without streaming
              finalResponse = mcpContent + '\n\n' + kbContent;
              streamingMessage.setText(finalResponse);
            }
          } else if (mcpContent) {
            // Stream a refined response for MCP-only content with conversation context
            try {
              let refinePrompt = '';
              if (conversationHistory.length > 0) {
                const recentHistory = conversationHistory.slice(-6).map(msg =>
                  `${msg.role === 'user' ? 'User' : 'Assistant'}: ${msg.parts[0].text.substring(0, 150)}...`
                ).join('\n');
                refinePrompt = `Previous conversation:\n${recentHistory}\n\n---\n\nUser's latest question: ${userMessage}\n\nData retrieved:\n${mcpContent}\n\nProvide a natural, helpful response based on the data and conversation context:`;
              } else {
                refinePrompt = `Rephrase and present this information naturally and helpfully to the user. Keep all the data accurate but make it conversational:\n\n${mcpContent}`;
              }
              const refinePayload = {
                contents: [{
                  role: 'user',
                  parts: [{ text: refinePrompt }]
                }],
                generationConfig: { temperature: 0.3, topP: 0.95 }
              };
              finalResponse = await streamGeminiResponse(refinePayload, 'gemini-2.0-flash', streamingMessage);
            } catch (err) {
              // Fallback to non-streamed
              finalResponse = mcpContent;
              streamingMessage.setText(finalResponse);
            }
          } else if (kbContent) {
            // Stream the KB content directly (already formatted)
            // Simulate streaming by adding text in chunks
            const words = kbContent.split(' ');
            finalResponse = '';
            for (let i = 0; i < words.length; i++) {
              finalResponse += (i > 0 ? ' ' : '') + words[i];
              streamingMessage.setText(finalResponse);
              // Small delay to simulate streaming effect
              if (i % 5 === 0) {
                await new Promise(r => setTimeout(r, 20));
              }
            }
          } else {
            // Neither worked
            if (mcpResult.error && kbResult.error) {
              finalResponse = 'I was unable to retrieve information for your query. Please try rephrasing your question.';
            } else {
              finalResponse = 'No relevant information found for your query.';
            }
            streamingMessage.setText(finalResponse);
          }

          // Add sources at the end if available
          if (sources.length > 0) {
            finalResponse += '\n\n**Sources:** ' + sources.join(', ');
            streamingMessage.setText(finalResponse);
          }

          // Finalize the streaming message (remove cursor)
          streamingMessage.finalize();

          // Update conversation history
          conversationHistory.push({ role: 'user', parts: [{ text: userMessage }] });
          conversationHistory.push({ role: 'model', parts: [{ text: finalResponse }] });

        } catch (err) {
          // Safely remove typing indicator if it still exists
          if (typingEl && typingEl.parentNode) {
            typingEl.remove();
          }
          console.error('Chat error:', err);

          if (err.message.includes('API key')) {
            showError('Invalid API key. Please check your Gemini API key.');
          } else {
            showError(`Error: ${err.message}`);
          }
        } finally {
          isProcessing = false;
          sendBtn.disabled = false;
          chatInput.disabled = false;
          chatInput.focus();
        }
      }

      // UI helpers
      function addMessage(role, content) {
        const messageEl = document.createElement('div');
        messageEl.className = `message ${role}`;

        const avatar = role === 'user' ? 'You' : 'VS';
        const formattedContent = formatMessage(content);

        messageEl.innerHTML = `
          <div class="message-avatar">${avatar}</div>
          <div class="message-content">${formattedContent}</div>
        `;

        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
      }

      // Create a streaming message bubble that can be updated
      function createStreamingMessage() {
        const messageEl = document.createElement('div');
        messageEl.className = 'message assistant';
        messageEl.innerHTML = `
          <div class="message-avatar">VS</div>
          <div class="message-content"><span class="streaming-cursor">▊</span></div>
        `;
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;

        const contentEl = messageEl.querySelector('.message-content');
        let currentText = '';

        return {
          element: messageEl,
          // Update with new text chunk
          appendText: (text) => {
            currentText += text;
            contentEl.innerHTML = formatMessage(currentText) + '<span class="streaming-cursor">▊</span>';
            chatMessages.scrollTop = chatMessages.scrollHeight;
          },
          // Finalize the message (remove cursor)
          finalize: () => {
            contentEl.innerHTML = formatMessage(currentText);
            chatMessages.scrollTop = chatMessages.scrollHeight;
          },
          // Get current text
          getText: () => currentText,
          // Set full text
          setText: (text) => {
            currentText = text;
            contentEl.innerHTML = formatMessage(currentText) + '<span class="streaming-cursor">▊</span>';
            chatMessages.scrollTop = chatMessages.scrollHeight;
          }
        };
      }

      // Stream content from Gemini API
      async function streamGeminiResponse(payload, model, streamingMessage) {
        const url = `${GEMINI_API_BASE}/${model}:streamGenerateContent?key=${geminiApiKey}&alt=sse`;

        try {
          const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });

          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error?.message || 'Streaming request failed');
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let fullText = '';

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;

            const chunk = decoder.decode(value, { stream: true });
            // Parse SSE data - each chunk may have multiple "data:" lines
            const lines = chunk.split('\n');

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                const jsonStr = line.slice(6);
                if (jsonStr.trim() === '[DONE]') continue;

                try {
                  const data = JSON.parse(jsonStr);
                  const candidates = data.candidates || [];
                  if (candidates.length > 0) {
                    const parts = candidates[0].content?.parts || [];
                    for (const part of parts) {
                      if (part.text) {
                        fullText += part.text;
                        streamingMessage.setText(fullText);
                      }
                    }
                  }
                } catch (e) {
                  // Ignore parse errors for partial JSON
                }
              }
            }
          }

          return fullText;
        } catch (err) {
          console.error('Streaming error:', err);
          throw err;
        }
      }

      function formatMessage(content) {
        let formatted = escapeHtml(content);
        formatted = formatted.replace(/```(\w*)\n([\s\S]*?)```/g, '<pre><code>$2</code></pre>');
        formatted = formatted.replace(/`([^`]+)`/g, '<code>$1</code>');
        formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        formatted = formatted.replace(/\*([^*]+)\*/g, '<em>$1</em>');
        formatted = formatted.replace(/\n/g, '<br>');
        return formatted;
      }

      function showTypingIndicator() {
        const typingEl = document.createElement('div');
        typingEl.className = 'message assistant';
        typingEl.innerHTML = `
          <div class="message-avatar">VS</div>
          <div class="typing-indicator">
            <span></span>
            <span></span>
            <span></span>
          </div>
        `;
        chatMessages.appendChild(typingEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        return typingEl;
      }

      function showError(message) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = message;
        chatMessages.appendChild(errorEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
        setTimeout(() => errorEl.remove(), 10000);
      }

      function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
      }

      // Initialize
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
{% endblock %}
